import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport xarray as xrimport cartopy.crs as ccrs  # %% Cell 1: Import climate dataimport osfrom matplotlib.colors import LinearSegmentedColormapfrom calendar import monthrangeimport geopandas as gpdfrom scipy.stats import linregressfrom cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER# %% Cell 1: Define functions for processingdef plot_vars_var(variable):    if variable == "pr":        var_suffix = "PR"        mode_suff = 'total'        vmin = -40        vmax = 40        zero_scaled = (abs(vmin)/(abs(vmin)+abs(vmax)))        colors = [(0, 'xkcd:mocha'), (zero_scaled,                                      'xkcd:white'), (1, 'xkcd:aquamarine')]        custom_cmap = LinearSegmentedColormap.from_list(            'custom_cmap', colors)    elif variable == "tas":        var_suffix = "TEMP"        vmin = -1.5        vmax = 1.5        mode_suff = 'total'        zero_scaled = (abs(vmin)/(abs(vmin)+abs(vmax)))        colors = [(0, 'cornflowerblue'), (zero_scaled,                                          'xkcd:white'), (1, 'xkcd:tomato')]        custom_cmap = LinearSegmentedColormap.from_list(            'custom_cmap', colors)    return var_suffix, vmin, vmax, mode_suff, zero_scaled, colors, custom_cmapdef plot_vars_time(timeframe):    if timeframe == 'monthly':        figsize = (18, 10)        fig, axes = plt.subplots(nrows=3, ncols=4, subplot_kw={                                 'projection': ccrs.PlateCarree()}, figsize=figsize)        time_signature = 'ymon'        timestamps = ['JAN', 'FEB', 'MAR', 'APR', 'MAY',                      'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC']        time_averaging = 'time.month'        time_type = 'month'        col_wrap = 4    if timeframe == 'seasonal':        figsize = (9, 7)        fig, axes = plt.subplots(nrows=2, ncols=2, subplot_kw={                                 'projection': ccrs.PlateCarree()}, figsize=figsize)        time_signature = 'yseas'        timestamps = ['DJF', 'MAM', 'JJA', 'SON']        time_averaging = 'time.season'        time_type = 'season'        col_wrap = 2    if timeframe == 'annual':        figsize = (7, 5)        fig, axes = plt.subplots(nrows=1, ncols=1, subplot_kw={                                 'projection': ccrs.PlateCarree()}, figsize=figsize)        time_signature = 'year'        timestamps = ['YEAR']        time_averaging = 'time.year'        time_type = 'year'        col_wrap = 1    return figsize, fig, axes, time_signature, timestamps, time_averaging, time_type, col_wrapdef calculate_trend(data, timeframe='annual'):    """    Calculate trends based on the specified timeframe. Assumes data is already resampled to the desired timeframe.    Parameters:    - data (xarray.DataArray): Input DataArray with dimensions ['time', 'lat', 'lon'].    - timeframe (str): 'annual', 'monthly', or 'seasonal' to specify the type of trend calculation.    Returns:    - xarray.DataArray: DataArray with the calculated trends.    """    def linregress_slope(y, x):        if np.any(np.isnan(y)):            return np.nan  # Return NaN if any value is NaN        slope, _, _, _, _ = linregress(x, y)        return slope    # Create a numeric time index based on the current data    if timeframe == 'annual':        # For annual data, use the year directly as the time index        time_index = data['time'].dt.year        # Normalize the time index to start from zero        x = time_index - time_index.min()        # Calculate the trend across the provided timeframe        trend = xr.apply_ufunc(            linregress_slope, data,            input_core_dims=[['time']],            vectorize=True,            kwargs={'x': x.values},            output_dtypes=[float]        )    elif timeframe == 'monthly':        # Calculate the trend separately for each month        def calculate_monthly_trend(group):            # Create a time index for the group            time_index = group['time'].dt.year            x = time_index - time_index.min()  # Normalize the time index            # Calculate the trend for this group (specific month across all years)            return xr.apply_ufunc(                linregress_slope, group,                input_core_dims=[['time']],                vectorize=True,                kwargs={'x': x.values},                output_dtypes=[float]            )        # Apply the trend calculation grouped by each month        trend = data.groupby('time.month').map(calculate_monthly_trend)    elif timeframe == 'seasonal':        # Resample the data to seasonal frequency        def calculate_seasonal_trend(group):            # Create a time index for the group            time_index = group['time'].dt.year            x = time_index - time_index.min()  # Normalize the time index            # Calculate the trend for this group (specific month across all years)            return xr.apply_ufunc(                linregress_slope, group,                input_core_dims=[['time']],                vectorize=True,                kwargs={'x': x.values},                output_dtypes=[float]            )        # Apply the trend calculation grouped by each month        trend = data.groupby('time.season').map(calculate_seasonal_trend)    else:        raise ValueError(            "Invalid timeframe specified. Choose from 'annual', 'monthly', or 'seasonal'.")    return trenddef calculate_percentage_change(trend, data, timeframe='annual', base_year=1985, num_years=29):    """    Calculate the percentage change in trend relative to the values from a base year.    Parameters:    - trend (xarray.DataArray): DataArray with the calculated trend slopes.    - data (xarray.DataArray): Original data with dimensions ['time', 'lat', 'lon'].    - timeframe (str): 'annual', 'monthly', or 'seasonal' to specify the type of trend calculation.    - base_year (int): The year to use as the baseline for comparison (default is 1985).    - num_years (int): The number of years over which to measure the change (default is 29).    Returns:    - xarray.DataArray: DataArray with the calculated percentage change.    """    if timeframe == 'annual':        # Extract the baseline value for 1985        # base_values = data.sel(time=str(base_year)).mean(dim='time')        base_values = data.mean(dim='time')  # for 30 yr annual average        # Calculate the percentage change        percentage_change = (trend) / base_values * 100        # Handle division by zero or very small base values (optional)        percentage_change = percentage_change.where(base_values != 0)        print("base values", base_values)        print("% values", percentage_change)    elif timeframe == 'monthly':        # Group baseline data by month to calculate 30-year monthly average        base_values = data.groupby('time.month').mean(dim='time')        # Group trend data by month        monthly_trend = trend  # .groupby('time.month').mean(dim='time')        # Calculate percentage change for all months at once        percentage_change = (monthly_trend) / base_values * 100        # Handle division by zero or very small base values (optional)        percentage_change = percentage_change.where(base_values != 0)    elif timeframe == 'seasonal':        # Group baseline and trend data by season        base_values = baseline.groupby('time.season').mean(dim='time')        seasonal_trend = trend  # .groupby('time.season').mean()        print(base_values)        # Calculate the percentage change directly for all seasons        # because baseline values are monthly        percentage_change = (seasonal_trend) / base_values * 100        # Handle division by zero or very small base values (optional)        percentage_change = percentage_change.where(base_values != 0)    else:        raise ValueError(            "Invalid timeframe specified. Choose from 'annual', 'monthly', or 'seasonal'.")    return percentage_change# %% Cell 2: Process the CRU data (field observations)# data is processed in the 02. Process and plot climate data and perturbations# %% Run the trend calculationplot = "off"# W5E5 is included in the models to make a baseline output filefor var in ["Precipitation"]:  # , "Temperature"]:    for timeframe in ["annual", "seasonal", "monthly"]:        for model in ["W5E5"]:  # "CRU"]:#, "W5E5"]:            print(model, timeframe, var)            # load the baseline data derived from OGGM uni-bremen server - after processing            ifolder_baseline_pr = f"/Users/magaliponds/OneDrive - Vrije Universiteit Brussel/1. VUB/02. Coding/01. IRRMIP/03. Data/03. Output files/01. Climate data/01. Processed input data/Precipitation/{timeframe}/{model}/0"            ifolder_baseline_tas = f"/Users/magaliponds/OneDrive - Vrije Universiteit Brussel/1. VUB/02. Coding/01. IRRMIP/03. Data/03. Output files/01. Climate data/01. Processed input data/Temperature/{timeframe}/{model}/0"            y0 = 1985  # or 1901            ye = 2014  # or 2020            ifile_baseline_pr = f"{ifolder_baseline_pr}/{model}.PR.BASE.000.{y0}_{ye}_{timeframe}_abs.nc"            ifile_baseline_tas = f"{ifolder_baseline_tas}/{model}.TEMP.BASE.000.{y0}_{ye}_{timeframe}_abs.nc"            if timeframe == 'seasonal':                time_averaging = "QS-DEC"            if timeframe == 'annual':                time_averaging = 'YE'            """ Part 0 - Load and open the climate data"""            # paths to climate data            # The baseline contains two seperate files for tas en pr and rename coordinates to match            if var == "Precipitation":                # total monthly precipitation timeseries                ifile = xr.open_dataset(ifile_baseline_pr)                var_short = "pr"                var_suffix = "PR"            else:                # monthly average tas timeseries                ifile = xr.open_dataset(ifile_baseline_tas)                var_suffix = "TEMP"                var_short = "tas"            # select only the data for the relevant timeframe            # base_range = pd.date_range(start='1985-01-01', end='2014-12-31', freq='MS')            baseline = ifile            trend = calculate_trend(baseline, timeframe)            if var_short == "pr":                trend_relative = calculate_percentage_change(                    trend, baseline, timeframe, base_year=1985, num_years=29)            # save output data            ofolder_baseline = f"/Users/magaliponds/OneDrive - Vrije Universiteit Brussel/1. VUB/02. Coding/01. IRRMIP/03. Data/03. Output files/01. Climate data/02. Perturbations/{var}/{timeframe}/{model}/0"            os.makedirs(ofolder_baseline, exist_ok=True)            os.makedirs(ofolder_baseline, exist_ok=True)            ofile_baseline_pr = f"{ofolder_baseline}/{model}.PR.BASE.000.{y0}_{ye}_{timeframe}_abs.nc"            ofile_baseline_pr_rel = f"{ofolder_baseline}/{model}.PR.BASE.000.{y0}_{ye}_{timeframe}_rel.nc"            ofile_baseline_tas = f"{ofolder_baseline}/{model}.TEMP.BASE.000.{y0}_{ye}_{timeframe}_abs.nc"            if var == "Precipitation":                trend.to_netcdf(ofile_baseline_pr)                trend_relative.to_netcdf(ofile_baseline_pr_rel)            else:                trend.to_netcdf(ofile_baseline_tas)# %%""" Part 3 - Plot the data """shapefile_path = '/Users/magaliponds/Library/CloudStorage/OneDrive-VrijeUniversiteitBrussel/1. VUB/02. Coding/01. IRRMIP/03. Data/01. Input files/03. Shapefile/Karakoram/Pan-Tibetan Highlands/Pan-Tibetan Highlands (Liu et al._2022)/Shapefile/Pan-Tibetan Highlands (Liu et al._2022)_P.shp'shp = gpd.read_file(shapefile_path)target_crs = 'EPSG:4326'shp = shp.to_crs(target_crs)full_vars = ["Precipitation", "Temperature"]for m, model in enumerate(["W5E5", "CRU"]):    for v, var in enumerate(['pr', 'tas']):  # 'pr','tas']):        full_var = full_vars[v]        for timeframe in ["annual", "seasonal", "monthly"]:            print(model, timeframe)            ifolder_baseline = f"/Users/magaliponds/OneDrive - Vrije Universiteit Brussel/1. VUB/02. Coding/01. IRRMIP/03. Data/03. Output files/01. Climate data/02. Perturbations/{full_var}/{timeframe}/{model}/0"            ifile_baseline_tas = f"{ifolder_baseline}/{model}.TEMP.BASE.000.{y0}_{ye}_{timeframe}_abs.nc"            ifile_baseline_pr = f"{ifolder_baseline}/{model}.PR.BASE.000.{y0}_{ye}_{timeframe}_rel.nc"            var_suffix, vmin, vmax, mode_suff, zero_scaled, colors, custom_cmap = plot_vars_var(                var)            figsize, fig, axes, time_signature, timestamps, time_averaging, time_type, col_wrap = plot_vars_time(                timeframe)            if var == "pr":                # total monthly precipitation timeseries                baseline = xr.open_dataset(ifile_baseline_pr)*30                variable = "Precipitation"            else:                # monthly average tas timeseries                baseline = xr.open_dataset(ifile_baseline_tas)*30                variable = "Temperature"            for time_idx, timestamp_name in enumerate(timestamps):                # indicate the column and row of the subplot to plot in                if timeframe == 'monthly':                    row = (time_idx) // 4  # Calculate row index                    col = (time_idx) % 4                    ax = axes[row, col]                if timeframe == 'seasonal':                    row = (time_idx) // 2                    col = (time_idx) % 2                    ax = axes[row, col]                if timeframe == 'annual':                    row = 0                    col = 0                    ax = axes                # include only the karakoram part                baseline = baseline.where((baseline.lon >= 60) & (baseline.lon <= 109) & (                    baseline.lat >= 22) & (baseline.lat <= 52), drop=True)                """ 3A Plotting data, incl karakoram outline """                # select relevant month/season and only 1 year for annual to plot and annotate                time_dim_name = list(baseline[var].dims)[0]                if timeframe == 'annual':                    base_sel = baseline[var]                else:                    base_sel = baseline[var].isel({time_dim_name: time_idx})                # make into dataframe, else it doesnt work                if isinstance(base_sel, xr.Dataset):                    base_sel = base_sel[list(base_sel.data_vars.keys())[0]]                # plot the data incl the outline of the karakoram shapefile, setting the colors, but excluding the shapefile                im = base_sel.plot.imshow(ax=ax, vmin=vmin, vmax=vmax, extend='both',                                          transform=ccrs.PlateCarree(), cmap=custom_cmap, add_colorbar=False)                shp.plot(ax=ax, edgecolor='black',                         linewidth=1, facecolor='none')                # shp.plot(ax=ax, edgecolor='red', linewidth=1, facecolor='none')                ax.coastlines(resolution='10m')                # include month as a label, instead as on top off data                ax.set_title('')                ax.annotate(timestamp_name, xy=(1, 1), xytext=(-10, -10), xycoords='axes fraction', textcoords='offset points',                            ha='right', va='top', fontsize=15, bbox=dict(boxstyle='square', fc='white', alpha=1))                """ 3B - Min and Max value annotation"""                # Include annotation for min and max values in every subplot, excluding NaN from min/max creation                base_sel_min = base_sel.fillna(base_sel.max())                base_sel_max = base_sel.fillna(base_sel.min())                # find min and max values in gridcell                min_value_index = np.unravel_index(                    np.argmin(base_sel_min.values), base_sel_min.shape)                max_value_index = np.unravel_index(                    np.argmax(base_sel_max.values), base_sel_max.shape)                # Extract longitude and latitude corresponding to the minimum and maximum value indices                min_lon, min_lat = base_sel.lon.values[min_value_index[1]                                                       ], base_sel.lat.values[min_value_index[0]]                max_lon, max_lat = base_sel.lon.values[max_value_index[1]                                                       ], base_sel.lat.values[max_value_index[0]]                # Plot the dot on the subplot                ax.plot(min_lon, min_lat, marker='o', markersize=7,                        color='blue')  # Adjust marker properties as needed                ax.plot(max_lon, max_lat, marker='o', markersize=7,                        color='red')  # Adjust marker properties as needed                # #indicate annotations for min and max values in plot, formatted as percenteges for rel precipitation differences                min_value = base_sel[min_value_index]                max_value = base_sel[max_value_index]                if timeframe == 'annual':                    ax.annotate(f'Min: {min_value:.1f}', xy=(65, 50), xytext=(                        65, 50), fontsize=15, ha='left', va='top')                    ax.annotate(f'Max: {max_value:.1f}', xy=(78, 50), xytext=(                        78, 50), fontsize=15, ha='left', va='top')                    ax.plot(64, 49.4, marker='o', color='blue', markersize=5)                    ax.plot(77, 49.4, marker='o', color='red', markersize=5)                else:                    ax.annotate(f'Min: {min_value:.1f}', xy=(64, 50), xytext=(                        64, 50), fontsize=14, ha='left', va='top')                    ax.annotate(f'Max: {max_value:.1f}', xy=(84, 50), xytext=(                        84, 50), fontsize=14, ha='left', va='top')                    ax.plot(62, 49, marker='o', color='blue', markersize=5)                    ax.plot(82, 49, marker='o', color='red', markersize=5)                # Set the map gridlines                gl = ax.gridlines(draw_labels=True)                gl.top_labels = False                gl.right_labels = False                # Set x-ticks using latitude values                if col == 0:                    gl.ylabel_style = {'size': 15}                    gl.ylocator = plt.MaxNLocator(nbins=3)                else:                    gl.left_labels = False                if (timeframe == 'monthly' and row == 2) or (timeframe == 'seasonal' and row == 1) or (timeframe == 'annual'):                    gl.xlabel_style = {'size': 15}                    gl.xlocator = plt.MaxNLocator(nbins=3)                else:                    gl.bottom_labels = False                gl.xformatter = LONGITUDE_FORMATTER                gl.yformatter = LATITUDE_FORMATTER            """ 3C Add color bar for entire plot"""            # add cbar in the figure, for overall figure, not subplots            # Define the position of the colorbar            cbar_ax = fig.add_axes([0.92, 0.1, 0.02, 0.8])            cbar = fig.colorbar(im, cax=cbar_ax, extend='both')            # adjust subplot spacing to be smaller            plt.subplots_adjust(left=0.1, right=0.9, bottom=0.1,                                top=0.9, wspace=0.05, hspace=0.05)            # Set label and tick parameters for the colorbar            if variable == "Precipitation":                unit = (                    '%' if timeframe == "annual" else                    '%' if timeframe == "monthly" else                    '%' if timeframe == "seasonal" else                    'Unknown timeframe'                )            elif variable == "Temperature":                unit = (                    '°C' if timeframe == "annual" else                    '°C' if timeframe == "monthly" else                    '°C' if timeframe == "seasonal" else                    'Unknown timeframe'                )            else:                unit = 'Unknown'            """4 Include labels for the cbar and for the y and x axis"""            # Increase distance between colorbar label and colorbar            cbar.ax.yaxis.labelpad = 20            # if mode == 'dif':            cbar.set_label(                f'$\Delta$ {variable} (1985-2014) [{unit}]', size='15')            cbar.ax.tick_params(labelsize=15)            title = f"{model}"            if timeframe == 'monthly':                fig.text(0.5, 0.03, 'Longitude', ha='center', fontsize=15)                fig.text(0.03, 0.5, 'Latitude', va='center',                         rotation='vertical', fontsize=15)                fig.text(0.5, 0.92, title, ha='center', fontsize=20)            else:                fig.text(0.5, 0.01, 'Longitude', ha='center', fontsize=15)                fig.text(-0.02, 0.5, 'Latitude', va='center',                         rotation='vertical', fontsize=15)                fig.text(0.5, 0.92, title, ha='center', fontsize=20)            ofolder_trend = f"/Users/magaliponds/OneDrive - Vrije Universiteit Brussel/1. VUB/02. Coding/01. IRRMIP/04. Figures/01. Climate data/04. Trend analysis/{variable}/{model}"            # os.makedirs(f"o_folder_base/{scale}/{timeframe}/{var}/", exist_ok=True)            os.makedirs(f"{ofolder_trend}/", exist_ok=True)            diftype = "rel" if var == "Precipitation" else "abs"            o_file_name = f"{ofolder_trend}/{model}.{var_suffix}.DIF.000.1985_2014_{timeframe}_{diftype}.png"            plt.savefig(o_file_name, bbox_inches='tight')            plt.show()