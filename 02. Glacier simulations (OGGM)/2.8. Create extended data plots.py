# -*- coding: utf-8 -*-#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Wed Jul  3 15:36:52 2024@author: magalipondsThis script runs makes plots of the selected 3 regions (13-14-15) with Areas larger than 1km2 (3r_a1) for the extended data ssection of the manuscriptIt runs through the following stepsCell 0: Load data packagesCell 1: Set base parameters (dictionaries)Cell 2: Create mosaic subplots per model for the perturbations Cell 3: Plot the monthly T and P perturbations averaged over all modelsCell 4: Plot the regional mass balances per region in NoIrr and Irr case (boxplot ED)Cell 5: Annual runoff timeline plot HMA melt or runoff onlyCell 6: Make stacked figure with melt annual runoff and full year/3 months onlyCell 7: Map plot PT only (∆B attribution to P or T change )Cell 8: Analyse robustness of historic CESM2 data - close to median or not (ED figure 7)"""# %% Cell 0: Load data packages# -*- coding: utf-8 -*-import oggm# from OGGM_data_processing import process_perturbation_data# import mpl_axes_alignerimport concurrent.futuresfrom shapely.geometry import LineString, MultiLineStringimport astimport stringfrom matplotlib.lines import Line2Dimport oggmfrom oggm import utils, cfg, workflow, tasks, DEFAULT_BASE_URL, graphics, global_tasksfrom oggm.core import massbalance, flowlinefrom oggm.utils import floatyear_to_date, hydrodate_to_calendardatefrom oggm.sandbox import distribute_2dfrom oggm.sandbox.edu import run_constant_climate_with_biasimport geopandas as gpdimport matplotlib.pyplot as pltimport matplotlib.cm as cmimport matplotlib.colors as clrsfrom matplotlib.colors import ListedColormap, BoundaryNormfrom matplotlib.patches import ConnectionPatchimport xarray as xrimport osimport seaborn as snsimport salemfrom matplotlib.ticker import FuncFormatterimport pandas as pdimport numpy as npfrom matplotlib import animationfrom IPython.display import HTML, displayimport matplotlib.pyplot as pltimport cartopy.crs as ccrsimport cartopy.feature as cfeatureimport geopandas as gpdimport pandas as pdfrom scipy.optimize import curve_fitfrom scipy import statsfrom matplotlib.legend_handler import HandlerTuplefrom matplotlib.colors import LightSourcefrom tqdm import tqdmimport pickleimport sysimport textwrapimport matplotlib.patches as mpatchesimport matplotlib.lines as mlinesfrom matplotlib.colors import LinearSegmentedColormap, TwoSlopeNorm, Normalize, ListedColormapfrom mpl_toolkits.axes_grid1.inset_locator import inset_axesfrom shapely.geometry import Pointimport matplotlib.gridspec as gridspecfrom cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTERfrom matplotlib.patches import Rectangle, ConnectionPatchfrom mpl_toolkits.axes_grid1.inset_locator import inset_axesfunction_directory = "/Users/magaliponds/Library/CloudStorage/OneDrive-VrijeUniversiteitBrussel/1. VUB/02. Research/01. IRRMIP/src/05. Cleaned Code/ 02. Glacier simulations (OGGM)"sys.path.append(function_directory)# %% Cell 1: Set base parameters# colors = {#     "irr": ["#000000", "#777777"],#     "noirr": ["#6363FF", "#B1B1FF"],#     # much lighter versions of noirr colors#     "noirr_com": ["#A6A6FF", "#E0E0FF"],#     # much lighter grey fade of irr colors#     "irr_com": ["#C0C0C0", "#E0E0E0"],#     "cf": ["#FF5722", "#FFA780"],#     "Yellow": ["#FFC107", "#FFE08A"]# }xkcd_colors = clrs.XKCD_COLORS# colors = {#     "irr": ["#000000", "#555555"],  # Black and dark gray#     # Darker brown and golden yellow for contrast#     # "noirr": ["#f5bf03","#fbeaac"],#["#8B5A00", "#D4A017"], #fdde6c#     "noirr": ["dimgrey","darkgrey"],#["#8B5A00", "#D4A017"], #fdde6c#     # "noirr_com": ["#E3C565", "#F6E3B0"],  # Lighter, distinguishable tan shades ##     # "noirr_com": ["#380282", "#ceaefa"],  # Lighter, distinguishable tan shades ##     "noirr_com": ["#FFC107", "#FFF3CD"],  # Lighter, distinguishable tan shades ##     "irr_com": ["#fe4b03", "#D0D0D0"],  # Light gray, no change#     # "irr_com": ["#B5B5B5", "#D0D0D0"],  # Light gray, no change#     "cf": ["#004C4C", "#40E0D0"],#     "cf_com": ["#008B8B", "#40E0D0"],#     "cline": ["dimgrey", '#FFC107']# }colors_ssp = {    'ssp585': '#951b1e',    'ssp370': '#e71d25',    'ssp245': '#f79420',    'ssp126': '#173c66',    'ssp119': '#00adcf'}# Function to convert hex to RGBA with alphadef hex_to_rgba(hex_color, alpha=1.0):    return clrs.to_rgba(hex_color, alpha=alpha)def hex_with_alpha_to_hex(hex_color, alpha):    r, g, b, _ = clrs.to_rgba(hex_color)    r = int(alpha * r * 255 + (1 - alpha) * 255)    g = int(alpha * g * 255 + (1 - alpha) * 255)    b = int(alpha * b * 255 + (1 - alpha) * 255)    return f"#{r:02x}{g:02x}{b:02x}"colors = {    "irr": ["#000000", "#555555"],  # Black and dark gray    "noirr": ["dimgrey","darkgrey"],#["#8B5A00", "#D4A017"], #fdde6c    # "noirr_com": ["#FFC107", "#FFF3CD"],  # Lighter, distinguishable tan shades #    # "irr_com": ["#fe4b03", "#D0D0D0"],  # Light gray, no change    # "noirr_com": ["#FFA500", "#FFD580"],    # "irr_com": ["#00796B", "#388E3C"],    # Teal and deep green (distinct from SSPs)    # "noirr_com": ["#80CBC4", "#A5D6A7"],  # Light turquoise and mint    "irr_com": ["#A0522D", "#BF6C38"],     # Dry, earthy rust tones    "noirr_com": ["#E6A87D", "#F3D4B3"],   # Muted peach and tan    "cf": ["#004C4C", "#40E0D0"],    "cf_com": ["#008B8B", "#40E0D0"],    "cline": ["dimgrey", '#E6A87D'],    "cline_2": ["black", 'dimgrey'],    "irr_fut": [        colors_ssp['ssp126'],  # SSP126        colors_ssp['ssp370']   # SSP370    ],    # Future scenarios: same SSP colors but with alpha 0.5    "noirr_fut": [        hex_with_alpha_to_hex(colors_ssp['ssp126'], 0.5),        hex_with_alpha_to_hex(colors_ssp['ssp370'], 0.5)    ]}region_colors = {13: 'blue', 14: 'crimson', 15: 'orange'}colors_models = {    "W5E5": ["#000000"],  # "#000000"],  # Black    # Darker to lighter shades of purple    "E3SM": ["#785EF0", "#8F7BF1", "#A6A8F2"],    # Darker to lighter shades of pink    "CESM2": ["#DC267F", "#E58A9E", "#F0A2B6", "#F7BCC4"],    # Darker to lighter shades of orange    "CNRM": ["#FE6100", "#FE7D33", "#FE9A66", "#FEB799", "#FECDB5", "#FEF1E1"],    "IPSL-CM6": ["#FFB000"],    "NorESM": ["#FFC107", "#FFE08A"]  # Dark purple to lighter shades}members = [1, 3, 4, 6, 4, 1]members_averages = [1, 2, 3, 5, 3]models = ["IPSL-CM6", "E3SM", "CESM2", "CNRM", "NorESM", "W5E5"]models_shortlist = ["IPSL-CM6", "E3SM", "CESM2", "CNRM", "NorESM"]timeframe = "monthly"y0_clim = 1985ye_clim = 2014fig_path = '/Users/magaliponds/Library/CloudStorage/OneDrive-VrijeUniversiteitBrussel/1. VUB/02. Research/01. IRRMIP/04. Figures/98. Final Figures A+1km2/'folder_path = '/Users/magaliponds/Documents/00. Programming'wd_path = f'{folder_path}/04. Modelled perturbation-glacier interactions - R13-15 A+1km2/'sum_dir = os.path.join(wd_path, 'summary')# %% Cell 2: Create mosaic subplots per model pertrubationsdef plot_subplots(index, subplots, annotation, diff, timestamps, axes, shp, custom_cmap, timeframe, scale, title, vmin=None, vmax=None):    for time_idx, timestamp_name in enumerate(timestamps):        # Determine subplot location based on timeframe        if timeframe == 'monthly':            row = time_idx // 4  # Calculate row index            col = time_idx % 4            ax = axes[row, col]        elif timeframe == 'seasonal':            row = time_idx // 2            col = time_idx % 2            ax = axes[row, col]        elif timeframe == 'annual':            row, col = 0, 0            ax = axes        # Select time dimension based on scale and timeframe        if scale == "Local":            time_dim_name = list(diff.dims)[0]        elif scale == "Global" and timeframe != 'annual':            time_dim_name = list(diff.dims)[2]        # Select relevant data slice        if timeframe == 'annual':            diff_sel = diff        else:            diff_sel = diff.isel({time_dim_name: time_idx})        # Convert Dataset to DataArray if necessary        if isinstance(diff_sel, xr.Dataset):            diff_sel = diff_sel[list(diff_sel.data_vars.keys())[0]]        # Plot data and the Karakoram outline        im = diff_sel.plot.imshow(ax=ax, vmin=vmin, vmax=vmax, extend='both',                                  transform=ccrs.PlateCarree(), cmap=custom_cmap, add_colorbar=False)        shp.plot(ax=ax, edgecolor='black', linewidth=1, facecolor='none')        ax.coastlines(resolution='10m')        # Find min and max values, and annotate them        diff_sel_min = diff_sel.fillna(diff_sel.max())        diff_sel_max = diff_sel.fillna(diff_sel.min())        min_value_index = np.unravel_index(            np.argmin(diff_sel_min.values), diff_sel_min.shape)        max_value_index = np.unravel_index(            np.argmax(diff_sel_max.values), diff_sel_max.shape)        # Extract coordinates for min and max values        min_lon, min_lat = diff_sel.lon.values[min_value_index[1]                                               ], diff_sel.lat.values[min_value_index[0]]        max_lon, max_lat = diff_sel.lon.values[max_value_index[1]                                               ], diff_sel.lat.values[max_value_index[0]]        # Plot markers for min and max values        ax.plot(min_lon, min_lat, marker='o',                markersize=7, color='blue')  # Min marker        ax.plot(max_lon, max_lat, marker='o',                markersize=7, color='red')  # Max marker        min_value = diff_sel[min_value_index]        max_value = diff_sel[max_value_index]        # Annotate with the timestamp & min max values        ax.annotate(annotation, xy=(1, 1), xytext=(-10, -10), xycoords='axes fraction',                    textcoords='offset points', ha='right', va='top', fontsize=12,                    bbox=dict(boxstyle='square', fc='white', alpha=1))        if index == "A":            ax.annotate(f'Min: {min_value:.1f}', xy=(65, 50), xytext=(                65, 50), fontsize=12, ha='left', va='top')            ax.annotate(f'Max: {max_value:.1f}', xy=(81, 50), xytext=(                81, 50), fontsize=12, ha='left', va='top')            ax.plot(64, 49.5, marker='o', color='blue', markersize=5)            ax.plot(79, 49.5, marker='o', color='red', markersize=5)        # Set gridlines and labels        gl = ax.gridlines(draw_labels=True)        gl.top_labels = False        gl.right_labels = False        if index in ["A", "D"]:            gl.ylabel_style = {'size': 12}            gl.ylocator = plt.MaxNLocator(nbins=3)        else:            gl.left_labels = False        # (timeframe == 'monthly' and row == 2) or (timeframe == 'seasonal' and row == 1) or (timeframe == 'annual'):        if index in ["D", "E", "F"] or subplots != "on":            gl.xlabel_style = {'size': 12}            gl.xlocator = plt.MaxNLocator(nbins=3)        else:            gl.bottom_labels = False        gl.xformatter = LONGITUDE_FORMATTER        gl.yformatter = LATITUDE_FORMATTER        """4 Include labels for the cbar and for the y and x axis"""        ax.set_title(title)    return im# def plot_P_T_perturbations_avg(scale, var, timeframe, mode, diftype, plotsave):""" Part 0 - Set plotting parameters"""# y0 = 1985  # if running from 1901 to 1985, than indicate extra id of counterfactual to access the data# ye = 2014# if running from 1901 to 1985, than indicate extra id of counterfactual to access the datay0s = [1985, 1901]yes = [2014, 1985]extra_ids = ["", "_counterfactual"]ptb_types = ["Irr", "NoForcing"]scale = "Local"subplots = "on"# "Temperature"]:  # ,"Temperature"]:for var in ["Temperature", "Precipitation"]:    for timeframe in ["annual"]:  # :, "seasonal", "monthly"]:        for mode in ['dif']:  # , 'std']:            for y, y0 in enumerate(y0s):                ye = yes[y]                extra_id = extra_ids[y]                ptbtype = ptb_types[y]                if var == "Precipitation" and mode == 'dif':                    diftypes = ['abs', 'rel']                else:                    diftypes = ['abs']                for dif in diftypes:                    print(var, timeframe, dif)                    diftype = dif                    # plot_P_T_perturbations_avg(scale,var, timeframe, mode, dif, "off")                    # adjust figure sizes towards type of plot# adjust figure sizes towards type of plot                    if scale == "Global":                        if timeframe == 'monthly':                            figsize = (25, 12)                            fig, axes = plt.subplots(nrows=3, ncols=4, subplot_kw={                                                     'projection': ccrs.PlateCarree()}, figsize=figsize)                            time_signature = 'ymon'                            timestamps = ['JAN', 'FEB', 'MAR', 'APR', 'MAY',                                          'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC']                            time_averaging = 'time.month'                            time_type = 'month'                            col_wrap = 4                        if timeframe == 'seasonal':                            figsize = (12, 7.5)                            fig, axes = plt.subplots(nrows=2, ncols=2, subplot_kw={                                                     'projection': ccrs.PlateCarree()}, figsize=figsize)                            time_signature = 'yseas'                            timestamps = ['DJF', 'MAM', 'JJA', 'SON']                            time_averaging = 'time.season'                            time_type = 'season'                            col_wrap = 2                        if timeframe == 'annual':                            figsize = (7, 5)  # (50, 25)#(7, 5)                            fig, axes = plt.subplots(nrows=1, ncols=1, subplot_kw={                                                     'projection': ccrs.PlateCarree()}, figsize=figsize)                            time_signature = 'year'                            timestamps = ['YEAR']                            time_averaging = 'time.year'                            time_type = 'year'                            col_wrap = 1                    if scale == "Local":                        if timeframe == 'monthly':                            figsize = (18, 10)                            # fig, axes = plt.subplots(nrows=3, ncols=4, subplot_kw={                            #                          'projection': ccrs.PlateCarree()}, figsize=figsize)                            time_signature = 'ymon'                            timestamps = ['JAN', 'FEB', 'MAR', 'APR', 'MAY',                                          'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC']                            time_averaging = 'time.month'                            time_type = 'month'                            col_wrap = 4                        if timeframe == 'seasonal':                            figsize = (9, 7)                            # fig, axes = plt.subplots(nrows=2, ncols=2, subplot_kw={                            #                          'projection': ccrs.PlateCarree()}, figsize=figsize)                            time_signature = 'yseas'                            timestamps = ['DJF', 'MAM', 'JJA', 'SON']                            time_averaging = 'time.season'                            time_type = 'season'                            col_wrap = 2                        if timeframe == 'annual':                            figsize = (7, 5)                            # fig, axes = plt.subplots(nrows=1, ncols=5, subplot_kw={                            #                          'projection': ccrs.PlateCarree()}, figsize=figsize)                            time_signature = 'year'                            timestamps = ['YEAR']                            time_averaging = 'time.year'                            time_type = 'year'                            col_wrap = 1                    # Provide cbar ranges and colors for plots for different variables, modes (dif/std) and difference types (abs/rel)                    if var == "Precipitation":                        variable_name = "pr"                        var_suffix = "PR"                        if mode == 'dif' and diftype == 'rel':                            mode_suff = 'total'                            vmin = -20                            vmax = 20                            zero_scaled = (abs(vmin)/(abs(vmin)+abs(vmax)))                            colors = [(0, 'xkcd:mocha'), (zero_scaled,                                                          'xkcd:white'), (1, 'xkcd:aquamarine')]                            custom_cmap = LinearSegmentedColormap.from_list(                                'custom_cmap', colors)                        if mode == 'dif' and diftype == 'abs':                            mode_suff = 'total'                            vmin = -50                            vmax = 75                            zero_scaled = (abs(vmin)/(abs(vmin)+abs(vmax)))                            colors = [(0, 'xkcd:mocha'), (zero_scaled,                                                          'xkcd:white'), (1, 'xkcd:aquamarine')]                            custom_cmap = LinearSegmentedColormap.from_list(                                'custom_cmap', colors)                        if mode == 'std':                            mode_suff = 'std'                            vmin = -40                            vmax = 40                            zero_scaled = (abs(vmin)/(abs(vmin)+abs(vmax)))                            colors = [(0, 'xkcd:peach'), (zero_scaled, 'xkcd:white'),                                      (1, 'xkcd:light aquamarine')]                            custom_cmap = LinearSegmentedColormap.from_list(                                'custom_cmap', colors)                    elif var == "Temperature":                        variable_name = "tas"                        var_suffix = "TEMP"                        if mode == 'dif':                            mode_suff = 'total'                            vmin = -1.5                            vmax = 1.5                            zero_scaled = (abs(vmin)/(abs(vmin)+abs(vmax)))                            colors = [(0, 'cornflowerblue'), (zero_scaled,                                                              'xkcd:white'), (1, 'xkcd:tomato')]                            custom_cmap = LinearSegmentedColormap.from_list(                                'custom_cmap', colors)                        if mode == 'std':                            mode_suff = 'std'                            vmin = -1.5                            vmax = 1.5                            zero_scaled = (abs(vmin)/(abs(vmin)+abs(vmax)))                            colors = [(0, 'xkcd:lightblue'), (zero_scaled,                                                              'xkcd:white'), (1, 'xkcd:pink')]                            custom_cmap = LinearSegmentedColormap.from_list(                                'custom_cmap', colors)                    # Set label and tick parameters for the colorbar                    if var == "Precipitation":                        if mode == 'std' or diftype == 'abs':                            unit = 'mm'                        else:                            unit = '%'                    elif var == "Temperature":                        unit = '°C'                    else:                        unit = 'Unknown'                    members = [1, 3, 4, 6, 4]                    # members = [1, 1, 1, 1]                    all_diff = []  # create a dataset to add all member differences                    all_model_diffs = []                    models = ["IPSL-CM6", "E3SM", "CESM2", "CNRM", "NorESM"]                    for (m, model) in enumerate(models):                        model_diff = []                        for member in range(members[m]):                            # only open data for non model averages (except for IPSL-CM6 as only one member)                            if model == "IPSL-CM6" or member != 0:                                # Part 1: Delete                                diff_folder_in = f"/Users/magaliponds/OneDrive - Vrije Universiteit Brussel/1. VUB/02. Research/01. IRRMIP/03. Data/03. Output files/01. Climate data/03. Regridded Perturbations/{var}/{timeframe}/{model}/{member}"                                ifile_diff = f"{diff_folder_in}/REGRID.{model}.{var_suffix}.DIF.00{member}.{y0}_{ye}_{timeframe}_{diftype}{extra_id}.nc"                                diff = xr.open_dataset(ifile_diff)                                if scale == "Local":  # scale the data to the local scale                                    diff = diff.where((diff.lon >= 60) & (diff.lon <= 109) & (                                        diff.lat >= 22) & (diff.lat <= 52), drop=True)                                # loose all the filtered data (nan)                                diff_clean = diff.dropna(dim="lon", how="all")                                # include the values in the list for caluclating the avg difference by model                                model_diff.append(diff_clean)                                # include the values in the list for caluclating the avg difference over all models                                all_diff.append(diff_clean)                        all_model_diff = xr.concat(                            model_diff, dim="models").mean(dim="models")  # concatenate all models into a list averaged by model                        all_model_diffs.append(all_model_diff)                    all_model_diffs_avg = xr.concat(                        all_model_diffs, dim="models")  # concatenate all models                    all_diffs_avg = xr.concat(all_diff, dim="models").mean(                        dim="models")  # concatenate all members and calculate the mean over all the models                    """ Part 2 - Shapefile outline for Karakoram Area to be included"""                    # path to  shapefile                    shapefile_path = '/Users/magaliponds/Library/CloudStorage/OneDrive-VrijeUniversiteitBrussel/1. VUB/02. Research/01. IRRMIP/03. Data/01. Input files/03. Shapefile/Karakoram/Pan-Tibetan Highlands/Pan-Tibetan Highlands (Liu et al._2022)/Shapefile/Pan-Tibetan Highlands (Liu et al._2022)_P.shp'                    shp = gpd.read_file(shapefile_path)                    target_crs = 'EPSG:4326'                    shp = shp.to_crs(target_crs)                    indices = ["A", "B", "C", "D", "E", "F"]                    # Create the mosaic plot                    if subplots == "on":                        layout = """                        AAB                        AAC                        DEF                        """                        fig, axes = plt.subplot_mosaic(layout, subplot_kw={'projection': ccrs.PlateCarree()},                                                       figsize=figsize,                                                       gridspec_kw={'wspace': 0, 'hspace': 0.4})                    else:                        layout = """                        AA                        AA                        """                        fig, axes = plt.subplot_mosaic(layout, subplot_kw={'projection': ccrs.PlateCarree()},                                                       figsize=figsize,                                                       gridspec_kw={'wspace': 0, 'hspace': 0.4})                    # plot the irrmip difference                    im = plot_subplots(indices[0], subplots, (sum(members)-len(models)+1),                                       all_diffs_avg, timestamps, axes[indices[0]], shp, custom_cmap, timeframe, scale, f"IRRMIP", vmin=vmin, vmax=vmax)                    # Step 1: Calculate the mean across models for each grid point                    # mean_diff = xr.concat([diff[variable_name] for diff in all_model_diffs], dim="models").mean(dim="models")                    # Step 2: Calculate the absolute difference between each model and the mean                    # agreement_mask = xr.concat(                    #     [np.abs(diff['tas'] - mean_diff) for diff in all_model_diffs],                    #     dim="models"                    # )                    sign_diff = xr.concat([np.sign(diff[variable_name])                                          for diff in all_model_diffs], dim="models")                    agreement_on_sign = (                        abs(sign_diff.mean(dim="models")) >= 0.8)                    # Step 3: Combine the conditions to create the final mask                    # We need areas where all models are within 0.5 degrees and 80% agree on the sign                    # & agreement_mask.all(dim="models")                    within_threshold = agreement_on_sign                    # Step 4: Convert the mask to 2D by removing the singleton 'variable' dimension if needed                    within_threshold_2d = within_threshold.astype(                        int).squeeze()                    # Step 6: Overlay the mask with dots in areas where agreement criteria are met                    axes[indices[0]].contourf(                        all_diffs_avg.lon, all_diffs_avg.lat, within_threshold_2d,                        levels=[0.5, 1.5], colors='none', hatches=['////'], transform=ccrs.PlateCarree()                    )                    if subplots == "on":                        for (m, model) in enumerate(models):                            print(m+1)                            annotation = members[m] - \                                1 if model != "IPSL-CM6" else members[m]                            im_model = plot_subplots(indices[m+1], subplots, annotation,                                                     all_model_diffs_avg.sel(models=m), timestamps, axes[indices[m+1]], shp, custom_cmap, timeframe, scale, model, vmin=vmin, vmax=vmax)                    """ 3C Add color bar for entire plot"""                    # add cbar in the figure, for overall figure, not subplots                    # Define the position of the colorbar                    cbar_ax = fig.add_axes([0.92, 0.1, 0.02, 0.8])                    cbar = fig.colorbar(im, cax=cbar_ax, extend='both')                    # Increase distance between colorbar label and colorbar                    cbar.ax.yaxis.labelpad = 20                    if mode == 'dif':                        # cbar.set_label(f'$\Delta_{{ptb_type}}_{,{var}}$ [{unit}]', size='15')                        cbar.set_label(                            rf'$\Delta_{{{ptbtype}, {var}}}$ [{unit}]', size=15)                        if mode == 'std':                            cbar.set_label(                                f'{var} - model member std [{unit}]', size='15')                    cbar.ax.tick_params(labelsize=12)                    # adjust subplot spacing to be smaller                    plt.subplots_adjust(left=0.1, right=0.9, bottom=0.1,                                        top=0.9, wspace=0.05, hspace=0.05)                    hedging_patch = mpatches.Patch(                        label='80% of models agree on sign of change', hatch='////', edgecolor='black', facecolor='none')                    # Add the custom legend to the plot                    axes[indices[0]].legend(handles=[                                            hedging_patch], loc='lower center', bbox_to_anchor=(0.75, -0.9), fontsize=12)                    # if plotsave == 'save':                    o_folder_diff = "/Users/magaliponds/Library/CloudStorage/OneDrive-VrijeUniversiteitBrussel/1. VUB/02. Research/01. IRRMIP/04. Figures/01. Climate data/02. Perturbations/"                    os.makedirs(f"{o_folder_diff}/", exist_ok=True)                    o_file_name = f"{o_folder_diff}/Mosaic.{var}.{y0}_{ye}_{timeframe}_{diftype}{extra_id}.png"                    plt.savefig(o_file_name, bbox_inches='tight')                    plt.show()                    # return#%% Cell 3: Plot the monthly perturbations averaged over all models# def plot_P_T_perturbations_avg(scale, var, timeframe, mode, diftype, plotsave):""" Part 0 - Set plotting parameters"""y0 = 1985  # if running from 1901 to 1985, than indicate extra id of counterfactual to access the dataye = 2014extra_id = ""  # "_counterfactual"scale = "Local"subplots = "on"models = ["CESM2", "NorESM", "E3SM", "CNRM", "IPSL-CM6"]members = [4,4,3,5,1]variables = ["Temperature", "Precipitation"]diftypes = ["abs","rel"]plotsave="save"timeframe="monthly"mode='dif'def reverse_latitudes(ds):    latitudes = ds.lat.values    if latitudes[0] > latitudes[-1]:  # Latitudes are in descending order        # Reverse the latitude coordinates and data        ds = ds.reindex(lat=ds.lat[::-1])    return dsdef plot_P_T_perturbations(models, members, scale, var, timeframe, mode, diftype, plotsave, y0, ye):    """ Part 0 - Set plotting parameters"""    # adjust figure sizes towards type of plot    if scale == "Global":        if timeframe == 'monthly':            figsize = (25, 12)            fig, axes = plt.subplots(nrows=3, ncols=4, subplot_kw={                                     'projection': ccrs.PlateCarree()}, figsize=figsize)            time_signature = 'ymon'            timestamps = ['JAN', 'FEB', 'MAR', 'APR', 'MAY',                          'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC']            time_averaging = 'time.month'            time_type = 'month'            col_wrap = 4        if timeframe == 'seasonal':            figsize = (12, 7.5)            fig, axes = plt.subplots(nrows=2, ncols=2, subplot_kw={                                     'projection': ccrs.PlateCarree()}, figsize=figsize)            time_signature = 'yseas'            timestamps = ['DJF', 'MAM', 'JJA', 'SON']            time_averaging = 'time.season'            time_type = 'season'            col_wrap = 2        if timeframe == 'annual':            figsize = (7, 5)            fig, axes = plt.subplots(nrows=1, ncols=1, subplot_kw={                                     'projection': ccrs.PlateCarree()}, figsize=figsize)            time_signature = 'year'            timestamps = ['YEAR']            time_averaging = 'time.year'            time_type = 'year'            col_wrap = 1        if scale == "Local":        if timeframe == 'monthly':            figsize = (18, 10)            fig, axes = plt.subplots(nrows=3, ncols=4, subplot_kw={                                     'projection': ccrs.PlateCarree()}, figsize=figsize)            time_signature = 'ymon'            timestamps = ['JAN', 'FEB', 'MAR', 'APR', 'MAY',                          'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC']            time_averaging = 'time.month'            time_type = 'month'            col_wrap = 4        if timeframe == 'seasonal':            figsize = (9, 7)            fig, axes = plt.subplots(nrows=2, ncols=2, subplot_kw={                                     'projection': ccrs.PlateCarree()}, figsize=figsize)            time_signature = 'yseas'            timestamps = ['DJF', 'MAM', 'JJA', 'SON']            time_averaging = 'time.season'            time_type = 'season'            col_wrap = 2        if timeframe == 'annual':            figsize = (7, 5)            fig, axes = plt.subplots(nrows=1, ncols=1, subplot_kw={                                     'projection': ccrs.PlateCarree()}, figsize=figsize)            time_signature = 'year'            timestamps = ['YEAR']            time_averaging = 'time.year'            time_type = 'year'            col_wrap = 1        # Provide cbar ranges and colors for plots for different variables, modes (dif/std) and difference types (abs/rel)    if var == "Precipitation":        var_suffix = "PR"        var_index="pr"        if mode == 'dif' and diftype == 'rel':            mode_suff = 'total'            vmin = -40            vmax = 40                        brbg11 = plt.get_cmap('BrBG', 11)            colors = brbg11([i for i in range(brbg11.N)[2:-2]])  # Get list of 11 RGBA colors            custom_cmap = LinearSegmentedColormap.from_list('BrBG11', colors)                     if mode == 'dif' and diftype == 'abs':            mode_suff = 'total'            vmin = -50            vmax = 75            zero_scaled = (abs(vmin)/(abs(vmin)+abs(vmax)))            colors = [(0, 'xkcd:mocha'), (zero_scaled,                                          'xkcd:white'), (1, 'xkcd:aquamarine')]            custom_cmap = LinearSegmentedColormap.from_list(                'custom_cmap', colors)        if mode == 'std':            mode_suff = 'std'            vmin = -40            vmax = 40            zero_scaled = (abs(vmin)/(abs(vmin)+abs(vmax)))            colors = [(0, 'xkcd:peach'), (zero_scaled, 'xkcd:white'),                      (1, 'xkcd:light aquamarine')]            custom_cmap = LinearSegmentedColormap.from_list(                'custom_cmap', colors)        elif var == "Temperature":        var_suffix = "TEMP"        var_index = "tas"        if mode == 'dif':            mode_suff = 'total'            vmin = -1.5            vmax = 1.5            zero_scaled = (abs(vmin)/(abs(vmin)+abs(vmax)))            colors = [(0, 'cornflowerblue'), (zero_scaled,                                              'xkcd:white'), (1, 'xkcd:tomato')]            custom_cmap = LinearSegmentedColormap.from_list(                'custom_cmap', colors)        if mode == 'std':            mode_suff = 'std'            vmin = -1.5            vmax = 1.5            zero_scaled = (abs(vmin)/(abs(vmin)+abs(vmax)))            colors = [(0, 'xkcd:lightblue'), (zero_scaled,                                              'xkcd:white'), (1, 'xkcd:pink')]            custom_cmap = LinearSegmentedColormap.from_list(                'custom_cmap', colors)       all_model_diffs=[]    all_diff=[]    for (m, model) in enumerate(models):        model_diff = []        for member in range(members[m]):            # only open data for non model averages (except for IPSL-CM6 as only one member)            if model == "IPSL-CM6" or member != 0:                    # Part 1: Delete                diff_folder_in = f"/Users/magaliponds/OneDrive - Vrije Universiteit Brussel/1. VUB/02. Research/01. IRRMIP/03. Data/03. Output files/01. Climate data/03. Regridded Perturbations/{var}/{timeframe}/{model}/{member}"                ifile_diff = f"{diff_folder_in}/REGRID.{model}.{var_suffix}.DIF.00{member}.{y0}_{ye}_{timeframe}_{diftype}.nc"                diff = xr.open_dataset(ifile_diff)                    if scale == "Local":  # scale the data to the local scale                    diff = diff.where((diff.lon >= 65) & (diff.lon <= 109) & (                        diff.lat >= 24) & (diff.lat <= 50), drop=True)                # loose all the filtered data (nan)                diff_clean = diff.dropna(dim="lon", how="all")                # include the values in the list for caluclating the avg difference by model                model_diff.append(diff_clean)                # include the values in the list for caluclating the avg difference over all models                all_diff.append(diff_clean)        all_model_diff = xr.concat(            model_diff, dim="models").mean(dim="models")  # concatenate all models into a list averaged by model        all_model_diffs.append(all_model_diff)    all_model_diffs_avg = xr.concat(        all_model_diffs, dim="models")  # concatenate all models    all_diffs_avg = xr.concat(all_diff, dim="models").mean(        dim="models")  # concatenate all members and calculate the mean over all the models        diff = all_diffs_avg[var_index]     diff = reverse_latitudes(diff)    # if var == "Temperature":    #     irrigation = irrigation-273.15    #     baseline = baseline-273.15        if scale == "Local":        diff = diff.where((diff.lon >= 60) & (diff.lon <= 109) & (            diff.lat >= 22) & (diff.lat <= 52), drop=True)        # print("new diff")                    # create local minima/maxima, for axis of plot    local_min_diff = diff.quantile(0.25)    local_max_diff = diff.quantile(0.75)        """ Part 2 - Shapefile outline for Karakoram Area to be included"""    # path to  shapefile    shapefile_path = "/Users/magaliponds/Library/CloudStorage/OneDrive-VrijeUniversiteitBrussel/1. VUB/02. Research/01. IRRMIP/03. Data/02. QGIS/RGI outlines/GTN-G_O2regions_selected_clipped.shp"    shp = gpd.read_file(shapefile_path).to_crs('EPSG:4326')        """ Part 3 - Create subplots for IRR, NOI and DIF"""        # first create output folders for the data    o_folder_base = f"/Users/magaliponds/OneDrive - Vrije Universiteit Brussel/1. VUB/02. Research/01. IRRMIP/04. Figures/01. Climate data/01. Input data/{scale}/{var}/{model}/{member}"    o_folder_diff = f"/Users/magaliponds/OneDrive - Vrije Universiteit Brussel/1. VUB/02. Research/01. IRRMIP/04. Figures/01. Climate data/02. Perturbations/{scale}/{var}/{model}/{member}"        timestamps = timestamps[-1:] + timestamps[:-1] #move december to the front    for time_idx, timestamp_name in enumerate(timestamps):            # indicate the column and row of the subplot to plot in        if timeframe == 'monthly':            row = (time_idx) % 3  # Calculate row index            col = (time_idx) // 3            ax = axes[row, col]        if timeframe == 'seasonal':            row = (time_idx) // 2            col = (time_idx) % 2            ax = axes[row, col]        if timeframe == 'annual':            row = 0            col = 0            ax = axes            """ 3A Plotting data, incl karakoram outline """        # select relevant month/season and only 1 year for annual to plot and annotate        if scale == "Local":            print(list(diff.dims))            time_dim_name = list(diff.dims)[0]                    if scale == "Global":            if timeframe != 'annual':                time_dim_name = list(diff.dims)[0] #month is now first dimension            if timeframe == 'annual':            diff_sel = diff        else:            diff_sel = diff.isel({time_dim_name: time_idx})            # print("plotting diff_sel", diff_sel)            # make into dataframe, else it doesnt work        if isinstance(diff_sel, xr.Dataset):            diff_sel = diff_sel[list(diff_sel.data_vars.keys())[0]]            # plot the data incl the outline of the karakoram shapefile, setting the colors, but excluding the shapefile        im = diff_sel.plot.imshow(ax=ax, vmin=vmin, vmax=vmax, extend='both',                                  transform=ccrs.PlateCarree(), cmap=custom_cmap, add_colorbar=False)        shp.plot(ax=ax, edgecolor='black', linewidth=1, facecolor='none')        # shp.plot(ax=ax, edgecolor='red', linewidth=1, facecolor='none')            ax.coastlines(resolution='10m')            # include month as a label, instead as on top off data        if time_idx % 3 == 0:            if col == 0:               ax.set_title('DJF', fontweight='bold')            elif col == 1:                ax.set_title('MAM', fontweight='bold')            elif col == 2:                ax.set_title('JJA', fontweight='bold')            elif col == 3:                ax.set_title('SON', fontweight='bold')                    else:            ax.set_title('')        ax.annotate(timestamp_name, xy=(1, 1), xytext=(-10, -10), xycoords='axes fraction', textcoords='offset points',                    ha='right', va='top', fontsize=15, bbox=dict(boxstyle='square', fc='white', alpha=1))                ax.coastlines(resolution='10m')        ax.add_feature(cfeature.OCEAN, facecolor='white', zorder=3) #mask the ocean, as some nan data is not filtered out            """ 3B - Min and Max value annotation"""        # Include annotation for min and max values in every subplot, excluding NaN from min/max creation        # diff_sel_min = diff_sel.fillna(diff_sel.max())        # diff_sel_max = diff_sel.fillna(diff_sel.min())            # find min and max values in gridcell        # min_value_index = np.unravel_index(        #     np.argmin(diff_sel_min.values), diff_sel_min.shape)        # max_value_index = np.unravel_index(        #     np.argmax(diff_sel_max.values), diff_sel_max.shape)            # Extract longitude and latitude corresponding to the minimum and maximum value indices        # min_lon, min_lat = diff_sel.lon.values[min_value_index[1]        #                                        ], diff_sel.lat.values[min_value_index[0]]        # max_lon, max_lat = diff_sel.lon.values[max_value_index[1]        #                                        ], diff_sel.lat.values[max_value_index[0]]            # Plot the dot on the subplot        # ax.plot(min_lon, min_lat, marker='o', markersize=7,        #         color='blue')  # Adjust marker properties as needed        # ax.plot(max_lon, max_lat, marker='o', markersize=7,        #         color='red')  # Adjust marker properties as needed            #indicate annotations for min and max values in plot, formatted as percenteges for rel precipitation differences        # min_value = diff_sel[min_value_index]        # max_value = diff_sel[max_value_index]            # if scale == "Local":        #     if timeframe == 'annual':        #         ax.annotate(f'Min: {min_value:.1f}', xy=(65, 50), xytext=(        #             65, 50), fontsize=15, ha='left', va='top')        #         ax.annotate(f'Max: {max_value:.1f}', xy=(78, 50), xytext=(        #             78, 50), fontsize=15, ha='left', va='top')            #         ax.plot(64, 49.4, marker='o', color='blue', markersize=5)        #         ax.plot(77, 49.4, marker='o', color='red', markersize=5)        #     else:        #         ax.annotate(f'Min: {min_value:.1f}', xy=(64, 50), xytext=(        #             64, 50), fontsize=14, ha='left', va='top')        #         ax.annotate(f'Max: {max_value:.1f}', xy=(84, 50), xytext=(        #             84, 50), fontsize=14, ha='left', va='top')            #         ax.plot(62, 49, marker='o', color='blue', markersize=5)        #         ax.plot(82, 49, marker='o', color='red', markersize=5)        # if scale == "Global":        #     if timeframe == 'monthly':        #         ax.annotate(f'Min: {min_value:.1f}', xy=(        #             0, -75), xytext=(0, -75), fontsize=15, ha='left', va='top')        #         ax.annotate(f'Max: {max_value:.1f}', xy=(        #             85, -75), xytext=(85, -75), fontsize=15, ha='left', va='top')        #         ax.plot(-4, -78, marker='o', color='blue', markersize=5)        #         ax.plot(80, -78, marker='o', color='red', markersize=5)        #     else:        #         ax.annotate(f'Min: {min_value:.1f}', xy=(        #             0, -75), xytext=(0, -75), fontsize=15, ha='left', va='top')        #         ax.annotate(f'Max: {max_value:.1f}', xy=(        #             85, -75), xytext=(85, -75), fontsize=15, ha='left', va='top')        #         ax.plot(-4, -79, marker='o', color='blue', markersize=5)        #         ax.plot(80, -79, marker='o', color='red', markersize=5)            # Set the map gridlines        gl = ax.gridlines(draw_labels=False, visible=False)        gl.top_labels = False        gl.right_labels = False            # Set x-ticks using latitude values        if col == 0:            gl.ylabel_style = {'size': 15}            gl.ylocator = plt.MaxNLocator(nbins=3)            else:            gl.left_labels = False            if (timeframe == 'monthly' and row == 2) or (timeframe == 'seasonal' and row == 1) or (timeframe == 'annual'):            gl.xlabel_style = {'size': 15}            gl.xlocator = plt.MaxNLocator(nbins=3)            else:            gl.bottom_labels = False            gl.xformatter = LONGITUDE_FORMATTER        gl.yformatter = LATITUDE_FORMATTER                if col==0 and row==0:            if var =="Temperature":                ax.text(0.03,0.92, 'a', transform=ax.transAxes,fontweight='bold', fontsize=14) #annotate with an 'a'            else:                ax.text(0.03,0.92, 'b', transform=ax.transAxes,fontweight='bold', fontsize=14)                """ 3C Add color bar for entire plot"""    # add cbar in the figure, for overall figure, not subplots    # Define the position of the colorbar    cbar_ax = fig.add_axes([0.92, 0.1, 0.02, 0.8])    cbar = fig.colorbar(im, cax=cbar_ax, extend='both')        # adjust subplot spacing to be smaller    plt.subplots_adjust(left=0.1, right=0.9, bottom=0.1,                        top=0.9, wspace=0.05, hspace=0.05)        # Set label and tick parameters for the colorbar    if var == "Precipitation":        if mode == 'std' or diftype == 'abs':            unit = 'mm'        else:            unit = '%'    elif var == "Temperature":        unit = '°C'    else:        unit = 'Unknown'        """4 Include labels for the cbar and for the y and x axis"""    # Increase distance between colorbar label and colorbar    cbar.ax.yaxis.labelpad = 20    if mode == 'dif':        cbar.set_label(fr'$\Delta$ {var}$_{{\text{{Irr-NoIrr}}}}$ [{unit}]', size='18')        if mode == 'std':            cbar.set_label(f'{var} - model member std [{unit}]', size='15')    cbar.ax.tick_params(labelsize=15)        if timeframe == 'monthly':        fig.text(0.5, 0.05, 'Longitude', ha='center', fontsize=15)        fig.text(0.07, 0.5, 'Latitude', va='center',                 rotation='vertical', fontsize=15)        # fig.text(0.5, 0.92, model, ha='center', fontsize=20)    else:        fig.text(0.5, 0.01, 'Longitude', ha='center', fontsize=15)        fig.text(-0.02, 0.5, 'Latitude', va='center',                 rotation='vertical', fontsize=15)        # fig.text(0.5, 0.92, model, ha='center', fontsize=20)        if plotsave == 'save':        # os.makedirs(f"o_folder_base/{scale}/{timeframe}/{var}/", exist_ok=True)        fig_path = '/Users/magaliponds/Library/CloudStorage/OneDrive-VrijeUniversiteitBrussel/1. VUB/02. Research/01. IRRMIP/04. Figures/98. Final Figures A+1km2/01. Extended_Data'        # os.makedirs(f"{fig_path}/", exist_ok=True)        plt.savefig(f"{fig_path}/Multi_model_avg.{var_suffix}.DIF.{y0}_{ye}_{timeframe}_{diftype}.png", dpi=300, bbox_inches="tight", pad_inches=0.1)                # plt.savefig(, bbox_inches='tight')    plt.show()    return for v,var in enumerate(variables):    diftype = diftypes[v]    plot_P_T_perturbations(models, members, scale, var, timeframe, mode, diftype, plotsave, y0, ye)    #%% Cell 4: Regional mass balances per region in NoIrr and Irr case# Function to plot the boxplots# ylim=5 20# y = ylim-10x=1.3def plot_boxplot(data, position, label, color, colorline, alpha, is_noirr):    if position<5:        width=2    else:        width=1    q1 = np.percentile(data, 25)    q3 = np.percentile(data, 75)    median = np.median(data)    iqr_height = q3 - q1    lower_bound = q1 - 1.5 * iqr_height    upper_bound = q3 + 1.5 * iqr_height    filtered_data = data[(data >= lower_bound) & (data <= upper_bound)]    if len(filtered_data) > 0:        lower_whisker = filtered_data.min()        upper_whisker = filtered_data.max()    else:        lower_whisker = q1        upper_whisker = q3    # Draw the shaded IQR rectangle    rect = plt.Rectangle((position - width / 2, q1),                         width, iqr_height,                         facecolor=color, alpha=alpha,                         edgecolor='none', zorder=1)    ax.add_patch(rect)        rect = plt.Rectangle((position - width / 2, lower_whisker),                             width, upper_whisker - lower_whisker,                             facecolor=color, alpha=0.4, edgecolor='none', zorder=0)    ax.add_patch(rect)    # Draw the median line    ax.plot([position - width / 2 + 0.09, position + width / 2 -0.09],            [median, median],            color=colorline, linewidth=3, zorder=2)    # Optional styling    ax.tick_params(labelsize=10)    if p > 0:        fontweight = "medium"    else:        for spine in ax.spines.values():            spine.set_linewidth(2)        fontweight = "bold"    ax.set_ylim(-1550, 1500)    return rect, filtered_data.max()regions = [13, 14, 15]subregions = [9, 3, 3]df = pd.read_csv(    # f"{wd_path}masters/master_gdirs_r3_a5_rgi_date_A_V_RGIreg_B_hugo_Vcom_noIPSL.csv")    f"{wd_path}masters/master_gdirs_r3_a1_rgi_date_A_V_RGIreg_B_hugo_Vcom.csv")master_ds = df[(~df['sample_id'].str.endswith('0')) |  # Exclude all the model averages ending with 0 except for IPSL               (df['sample_id'].str.startswith('IPSL'))]# master_ds=master_ds[~master_ds['sample_id'].str.startswith('IPSL')] #to exclude IPSLmaster_ds['B_irr']=master_ds['B_irr']#/1000master_ds['B_noirr']=master_ds['B_noirr']#/1000master_ds = master_ds[['rgi_id', 'rgi_region', 'rgi_subregion','full_name', 'cenlon', 'cenlat', 'rgi_date', 'rgi_area_km2','rgi_volume_km3', 'sample_id', 'B_noirr', 'B_irr', 'B_delta', 'B_hugo','Area', 'errB_hugo','V_1985_irr']]master_ds_avg = master_ds.groupby(['rgi_id'], as_index=False).agg({  # calculate the 11 member average for noirr and delta, for irr the first value can be taken as they are all the same    'B_irr': 'mean',    'B_noirr': 'mean',    # lamda is anonmous functions, returns 11 member average    'sample_id': lambda _: "11 member average",    # take first value for all columns that are not in the list    **{col: 'first' for col in master_ds.columns if col not in ['B_irr', "B_noirr", "sample_id"]}})master_ds_avg = master_ds_avg[master_ds_avg['B_irr'].notna()]#group by subregion and calculate regional weighted average irr and noirr and total area and volume # master_ds_area_weighted = master_ds_avg.groupby(['rgi_subregion'], as_index=False).agg({#     'B_irr': lambda x: (x * master_ds_avg.loc[x.index, 'rgi_area_km2']).sum() / master_ds_avg.loc[x.index, 'rgi_area_km2'].sum(),#     'B_noirr': lambda x: (x * master_ds_avg.loc[x.index, 'rgi_area_km2']).sum() / master_ds_avg.loc[x.index, 'rgi_area_km2'].sum(),#     'rgi_area_km2': 'sum',  # Sum for area#     'rgi_volume_km3': 'sum',  # Sum for volume#     'V_1985_irr': 'sum',  # Sum for volume#     # 'sample_id': lambda _: "11 member average",#     # take first value for all columns that are not in the list#     **{col: 'first' for col in master_ds.columns if col not in ['B_irr', 'B_noirr','rgi_area_km2','rgi_volume_km3', 'V_1985_irr']}# })master_ds_area_weighted=master_ds_avguse_weights = True# v_space_noi2 = 1.9  # Vertical space between irr and noirr boxplotsv_space_com = 1.6  # Vertical space between irr and noirr boxplotsv_space_hist = 0.4  # Vertical space between irr and noirr boxplotsv_space_com_all = 2.3  # Vertical space between irr and noirr boxplotsv_space_hist_all = 0.1  # Vertical space between irr and noirr boxplots# v_space_irr1 = 0.1  # Vertical space between irr and noirr boxplots# Storage for combined dataall_noirr, all_irr = [], []position_counter = 1cumulative_index = 14# Initialize plotfig = plt.figure(figsize=(16, 6))gs = gridspec.GridSpec(1, 16, width_ratios=[1.5] + [1]*15)  # First axis twice as wide# axes = [fig.add_subplot(gs[i]) for i in range(16)]fig, axes = plt.subplots(1,1, figsize=(16, 6), sharey=True)print(axes)# axes = axes.flatten()p=5.4tick_positions=[]tick_labels=[]mean_list=[]# Example usage: Main loop through regions and subregionsfor r, region in enumerate((regions)):    for sub in range(list((subregions))[r]):        # Filter subregion-specific data        ax = axes        region_id = f"{region}.0{sub+1}"        print(region_id)               subregion_ds = master_ds_area_weighted[master_ds_area_weighted['rgi_subregion'].str.contains(            f"{region}-0{sub+1}")]        # Calculate mean values for Noirr and Irr        # noirr_mean = master_ds_area_weighted['V_2264_noirr'][cumulative_index]        # irr_mean = master_ds_area_weighted['V_2264_irr'][cumulative_index]        # Set color and label based on the region        try:            label = subregion_ds.full_name.iloc[0]        except:            label = f"{region}-0{sub+1}"                if region==13:            if sub ==1:                label = "Pamir"            elif sub ==3:                label = "East Tien Shan"            elif sub ==5:                label = "East Kun Lun"        # Plot Noirr and Irr boxplots        print(position_counter)                tick_positions.append(p +1 )#+ v_space_com -0.2)  # or average of hist + com if you want centered        tick_labels.append(label)                mean_hist = subregion_ds['B_irr'].median()        mean_noirr = subregion_ds['B_noirr'].median()         # mean_com_noirr = subregion_ds['V_2264_noirr_delta'].mean()           mean_list.append((region_id, mean_hist, mean_noirr))#, mean_com_noirr))                box_irr, bim = plot_boxplot(            subregion_ds['B_irr'], p + v_space_hist, label, color=colors['irr'][0],colorline=colors['cline_2'][0], alpha=0.4, is_noirr=False)        box_noirr, bnm = plot_boxplot(             subregion_ds['B_noirr'], p + v_space_com, label, color=colors['noirr'][1], colorline=colors['cline_2'][1], alpha=0.8, is_noirr=True)                # box_irr = ax.scatter([p +        #                        v_space_hist], subregion_ds['B_irr'].iloc[0], color=colors['irr'][0], marker="o", s=60, linewidths=3, zorder=10)        # box_irr = ax.scatter([p +        #                        v_space_com], subregion_ds['B_noirr'].iloc[0], color=colors['irr_com'][0], marker="o", s=60, linewidths=3, zorder=10)                ax.text(                p + v_space_hist -0.25,                         # x                bim+60,                 # y                str(int(round(subregion_ds['B_irr'].median(), 0))),     # text (must be a string!)                rotation=90,                fontsize=12            )                ax.text(                p + v_space_com -0.25,                         # x                bnm+60,                 # y                str(int(round(subregion_ds['B_noirr'].median(), 0))),     # text (must be a string!)                rotation=90,                fontsize=12            )                ax.text(                p+1, #,+ (v_space_com + v_space_hist)/2 -0.25,                         # x                -1500,                 # y                str(int(round(subregion_ds['B_irr'].median()-subregion_ds['B_noirr'].median(), 0))),     # text (must be a string!)                rotation=0,                fontsize=12, ha='center'            )        # ax.hlines(mean_hist,         #   xmin=p + v_space_hist - 0.5,  # adjust width        #   xmax=p + v_space_hist + 0.5,        #   linestyles='dotted',         #   color=colors['cline'][0],        #   linewidth=3,        #   zorder=9)                # ax.hlines(mean_com_noirr,         #   xmin=p + v_space_com - 0.5,  # adjust width        #   xmax=p + v_space_com + 0.5,        #   linestyles='dotted',         #   color=colors['cline'][1],        #   linewidth=3,        #   zorder=9)                # Annotate the number of glaciers and delta between the two columns        num_glaciers = len(master_ds[master_ds.rgi_subregion==f"{region}-0{sub+1}"][master_ds.sample_id=="IPSL-CM6.000"])                # delta = noirr_mean - irr_mean        # Display number of glaciers and delta        initial_volume = round(subregion_ds['V_1985_irr'].iloc[0]*1e-9)        # ax.text(p, y,         #          f'{initial_volume}\n({num_glaciers})',  # \nΔ = {delta:.2f}',        #          va='center', ha='left', fontsize=12, color='black',        #          backgroundcolor="white",  zorder=10)        ax.axvline(p-0.5, color='lightgrey', linestyle='--',                    linewidth=1, zorder=1)         p+=3            # # Plot overall average boxplots for Irr and Noirrp=1.2ax = axes#group by subregion and calculate regional weighted average irr and noirr and total area and volume # master_ds_hma = master_ds_avg.agg({#     'B_irr': lambda x: (x * master_ds_avg.loc[x.index, 'rgi_area_km2']).sum() / master_ds_avg.loc[x.index, 'rgi_area_km2'].sum(),#     'B_noirr': lambda x: (x * master_ds_avg.loc[x.index, 'rgi_area_km2']).sum() / master_ds_avg.loc[x.index, 'rgi_area_km2'].sum(),#     'rgi_area_km2': 'sum',  # Sum for area#     'rgi_volume_km3': 'sum',  # Sum for volume#     'V_1985_irr': 'sum',  # Sum for volume#     # 'sample_id': lambda _: "11 member average",#     # take first value for all columns that are not in the list#     # **{col: 'first' for col in master_ds.columns if col not in ['B_irr', 'B_noirr','rgi_area_km2','rgi_volume_km3', 'V_1985_irr']}# })master_ds_hma=master_ds_avg# avg_irr = ax.scatter([p +                       # v_space_hist_all], master_ds_hma['B_irr'], color=colors['irr'][0], marker="o", s=100, linewidths=4)# avg_irr = ax.scatter([p +                       # v_space_com_all], master_ds_hma['B_noirr'], color=colors['noirr'][0], marker="o", s=100, linewidths=4)avg_irr_hist,bim = plot_boxplot( master_ds_hma['B_irr'], p + v_space_hist_all, [    "High Mountain Asia"], color=colors['irr'][1], colorline=colors['cline_2'][0], alpha=0.8, is_noirr=True)avg_noi_com, bnm = plot_boxplot(master_ds_hma['B_noirr'], p + v_space_com_all, [    "High Mountain Asia"], color=colors['noirr'][1], colorline=colors['cline_2'][1], alpha=0.8, is_noirr=True)ax.text(        p + v_space_hist_all -0.25,                         # x        bim+60,                 # y        str(int(round(master_ds_hma['B_irr'].median(), 0))),     # text (must be a string!)        rotation=90,        fontsize=12    )ax.text(        p + v_space_com_all -0.25,                         # x        bnm+60,                 # y        str(int(round(master_ds_hma['B_noirr'].median(), 0))),     # text (must be a string!)        rotation=90,        fontsize=12)ax.text(        p-0.5, #,+ (v_space_com + v_space_hist)/2 -0.25,                         # x        -1500,                 # y        f"∆B$_{{Irr}}$={str(int(round(master_ds_hma['B_irr'].median()-master_ds_hma['B_noirr'].median(), 0)))}",     # text (must be a string!)        rotation=0,        fontsize=12, ha='left', fontweight='bold'    )        initial_total_volume = round(master_ds_hma['V_1985_irr']*1e-9)# Annotate the number of glaciers for the overall averagelength=len(master_ds[master_ds.sample_id == "CNRM.001"])# ax.text(v_space_hist, y, #          f"V:{initial_total_volume}\n(#:{length})",# Display total number of glaciers#          va='center', ha='left', fontsize=12, color='black',#           backgroundcolor="white", zorder=10)#fontstyle='italic',mean_hist = master_ds_hma['B_irr'].mean()mean_com_irr = master_ds_hma['B_noirr'].mean()# mean_com_noirr = master_ds_hma['V_2264_noirr_delta'].mean()# mean_list.append(("High Mountain Asia", mean_hist, mean_com_irr))# df_means = pd.DataFrame(mean_list, columns=["subregion", "V_2264_irr_delta","V_2264_noirr_delta"])# df_means.to_csv(f"{wd_path}masters/mean_deltaV_Comitted.csv")# Add a legend for regions, mean (dot), and median (stripe)region_legend_patches = [mpatches.Patch(color=colors['irr'][1], label='Historical (W5E5)'),                        mpatches.Patch(color=colors['noirr'][1], label='Historical NoIrr'),                        ]tick_positions.append(1 + v_space_com)tick_labels.append("High\nMountain\nAsia")# Set tick positions and rotated labels (except HMA)ax.set_xticks(tick_positions)ax.set_xticklabels(tick_labels, fontsize=14, rotation=30)# Override HMA rotation to be flat (if needed)for label in ax.get_xticklabels():    if label.get_text() == "High\nMountain\nAsia":        label.set_rotation(0)        label.set_fontweight("bold")        fig.legend(handles=region_legend_patches, loc='upper center',          bbox_to_anchor=(0.28, 0.88), ncols=5, fontsize=14,columnspacing=1.5)ax.set_ylabel('Glacier average mass Balance [mm w.e.]', labelpad=15, fontsize=14)fig.subplots_adjust(wspace=0.1)#, hspace=0.1)ax.set_xlim(0, 3*15+5)ax.tick_params(labelsize=12)# Include the panel plotax.axhline(y=0, color='grey', linestyle='--', linewidth=1, zorder=0)# output_nc_path = os.path.join(wd_path, "masters", "master_comitted_volume_timeseries_individual_member.nc")# # output_nc_path = os.path.join(wd_path, "masters", "master_comitted_volume_timeseries_individual_member_noIPSL.nc")# tlines = xr.open_dataset(output_nc_path)# ax_inset = inset_axes(ax, width="24%", height="32%", loc='lower left',bbox_to_anchor=(286,100,1800, 700))  # width/height can be % or float# for m,model in enumerate(models_shortlist):#     member_series = []#     times = None    #     for x in range(members_averages[m]):#         if x>0:#             ax_inset.plot(#                 tlines.sel(scenario='committed', model=model, member=x, experiment="NoIrr").time.values,#                tlines.sel(scenario='committed', model=model, member=x,experiment="NoIrr").volume_percent-100, ls=':', lw=1, color=colors['noirr_com'][0], zorder=1#             )            #             data = tlines.sel(scenario='committed', model=model, member=x, experiment="NoIrr")#             volume = data.volume_percent - 100#             member_series.append(volume)#             if times is None:#                 times = data.time.values            #     if member_series:#         stacked = xr.concat(member_series, dim='member')#         q25 = stacked.quantile(0.25, dim='member')#         q75 = stacked.quantile(0.75, dim='member')#         # Fill between 25th and 75th percentile#         ax_inset.fill_between(#             times, q25, q75,#             color=colors['noirr_com'][1],#             alpha=0.7,#             zorder=0#         )                                                                # ax_inset.plot(# tlines.sel(scenario='committed', model="W5E5", member=0, experiment="Irr").time.values,# tlines.sel(scenario='committed', model="W5E5", member=0,experiment="Irr").volume_percent-100, ls='-', lw=2, color=colors['irr_com'][0]# )# ax_inset.plot(# tlines.sel(scenario='committed', model="avg", member=0, experiment="NoIrr").time.values,# tlines.sel(scenario='committed', model="avg", member=0,experiment="NoIrr").volume_percent-100, ls='--', lw=2, color=colors['noirr_com'][0], zorder=0# )# # ax_inset.text(0.2, 0.95, "Committed evolution", fontsize=12,# #               transform=ax_inset.transAxes, va='top', ha='left')# # Set axis ticks and labels# ax_inset.set_xlim(2014,2264)# ax_inset.set_xticks([2114, 2214])# ax_inset.set_xticklabels(['100', '200 yrs'])# ax_inset.set_ylim(-30,10)# ax_inset.set_yticks([ 0, -10, -20])#, -30])# ax_inset.set_yticklabels([ '0%', '-10%', '-20%'])#, '-30%'])# # ax_inset.axhline(0, color='grey', linestyle='--', linewidth=1)# # ax_inset.yaxis.label.set_zorder(10)# # Tick marks and labels setup# ax_inset.tick_params(axis='both', which='both',#                      direction='in',     # tick lines point inside#                      length=5,           # visible tick length#                      top=False, bottom=True, left=False, right=True,#                      labelsize=12)# # Tick labels on right side of y-axis# ax_inset.yaxis.set_ticks_position('left')# ax_inset.yaxis.set_label_position("left")# ax_inset.grid(True, axis='both', which='major', linestyle=':', linewidth=0.5, color='gray')# for label in ax_inset.get_xticklabels():#     label.set_verticalalignment('top')#     label.set_y(0.2)  # smaller = closer to axis line (inside)# # Shift y-axis labels left into the plot# for label in ax_inset.get_yticklabels():#     label.set_horizontalalignment('left')#     label.set_x(0.05)  # smaller = closer to axis line (inside)    # rect_x = p + v_space_hist_all + 1.05# rect_y = -24# rect_w=2.25# rect_height=24# square = mpatches.Rectangle((rect_x, rect_y), rect_w, rect_height,#                                linewidth=0.7, edgecolor='black', facecolor='none')# ax.add_patch(square)# rect_x_zoom = 0.2# rect_y_zoom = ylim-110# rect_w_zoom=12# rect_height_zoom=30# square_zoom = mpatches.Rectangle((rect_x_zoom, rect_y_zoom), rect_w_zoom, rect_height_zoom,#                                linewidth=1, edgecolor='none', facecolor='none')# ax.add_patch(square_zoom)# # --- Convert rectangle data coordinates to figure coordinates ---# # Lower left and lower right corners of the rectangle# ll_data = (rect_x, rect_y)# lr_data = (rect_x + rect_w, rect_y)# ll_disp = ax.transData.transform(ll_data)# lr_disp = ax.transData.transform(lr_data)# ll_fig = fig.transFigure.inverted().transform(ll_disp)# lr_fig = fig.transFigure.inverted().transform(lr_disp)# # --- Get upper left and right of the inset in figure coordinates ---# # These are in the inset's axes coordinates, so (0, 1) is upper-left, (1, 1) is upper-right# ul_data_zoom = (rect_x_zoom, rect_y_zoom+rect_height_zoom)# ur_data_zoom = (rect_x_zoom + rect_w_zoom, rect_y_zoom+rect_height_zoom)# ul_disp_zoom = ax.transData.transform(ul_data_zoom)# ur_disp_zoom = ax.transData.transform(ur_data_zoom)# ul_fig_zoom = fig.transFigure.inverted().transform(ul_disp_zoom)# ur_fig_zoom = fig.transFigure.inverted().transform(ur_disp_zoom)# # --- Draw lines from rectangle to inset corners ---# line_left = mlines.Line2D([ll_fig[0], ul_fig_zoom[0]], [ll_fig[1], ul_fig_zoom[1]],#                           transform=fig.transFigure, color='black', linestyle='--', zorder=10, lw=0.7)# line_right = mlines.Line2D([lr_fig[0], ur_fig_zoom[0]], [lr_fig[1], ur_fig_zoom[1]],#                            transform=fig.transFigure, color='black', linestyle='--', zorder=10, lw=0.7)# ax.grid(True, axis='y', which='major', linestyle=':', linewidth=0.5, color='gray')# fig.lines.extend([line_left, line_right])plt.savefig(    f"{fig_path}/Boxplot_Mass_Balance_Extended_Data.png")plt.show()   #%% Cell 4:b Regional mass balances per region in NoIrr and Irr case - mean# Function to plot the boxplots# ylim=5 20# y = ylim-10x=1.3def plot_boxplot(data, position, label, color, colorline, alpha, is_noirr):    if position<5:        width=2    else:        width=1    q1 = np.percentile(data, 25)    q3 = np.percentile(data, 75)    median = np.mean(data)    iqr_height = q3 - q1    lower_bound = q1 - 1.5 * iqr_height    upper_bound = q3 + 1.5 * iqr_height    filtered_data = data[(data >= lower_bound) & (data <= upper_bound)]    if len(filtered_data) > 0:        lower_whisker = filtered_data.min()        upper_whisker = filtered_data.max()    else:        lower_whisker = q1        upper_whisker = q3    # Draw the shaded IQR rectangle    rect = plt.Rectangle((position - width / 2, q1),                         width, iqr_height,                         facecolor=color, alpha=alpha,                         edgecolor='none', zorder=1)    ax.add_patch(rect)        rect = plt.Rectangle((position - width / 2, lower_whisker),                             width, upper_whisker - lower_whisker,                             facecolor=color, alpha=0.4, edgecolor='none', zorder=0)    ax.add_patch(rect)    # Draw the median line    ax.plot([position - width / 2 + 0.09, position + width / 2 -0.09],            [median, median],            color=colorline, linewidth=3, zorder=2)    # Optional styling    ax.tick_params(labelsize=10)    if p > 0:        fontweight = "medium"    else:        for spine in ax.spines.values():            spine.set_linewidth(2)        fontweight = "bold"    ax.set_ylim(-1550, 1500)    return rect, filtered_data.max()regions = [13, 14, 15]subregions = [9, 3, 3]df = pd.read_csv(    # f"{wd_path}masters/master_gdirs_r3_a5_rgi_date_A_V_RGIreg_B_hugo_Vcom_noIPSL.csv")    f"{wd_path}masters/master_gdirs_r3_a1_rgi_date_A_V_RGIreg_B_hugo_Vcom.csv")master_ds = df[(~df['sample_id'].str.endswith('0')) |  # Exclude all the model averages ending with 0 except for IPSL               (df['sample_id'].str.startswith('IPSL'))]# master_ds=master_ds[~master_ds['sample_id'].str.startswith('IPSL')] #to exclude IPSLmaster_ds['B_irr']=master_ds['B_irr']#/1000master_ds['B_noirr']=master_ds['B_noirr']#/1000master_ds = master_ds[['rgi_id', 'rgi_region', 'rgi_subregion','full_name', 'cenlon', 'cenlat', 'rgi_date', 'rgi_area_km2','rgi_volume_km3', 'sample_id', 'B_noirr', 'B_irr', 'B_delta', 'B_hugo','Area', 'errB_hugo','V_1985_irr']]master_ds_avg = master_ds.groupby(['rgi_id'], as_index=False).agg({  # calculate the 11 member average for noirr and delta, for irr the first value can be taken as they are all the same    'B_irr': 'mean',    'B_noirr': 'mean',    # lamda is anonmous functions, returns 11 member average    'sample_id': lambda _: "11 member average",    # take first value for all columns that are not in the list    **{col: 'first' for col in master_ds.columns if col not in ['B_irr', "B_noirr", "sample_id"]}})master_ds_avg = master_ds_avg[master_ds_avg['B_irr'].notna()]#group by subregion and calculate regional weighted average irr and noirr and total area and volume # master_ds_area_weighted = master_ds_avg.groupby(['rgi_subregion'], as_index=False).agg({#     'B_irr': lambda x: (x * master_ds_avg.loc[x.index, 'rgi_area_km2']).sum() / master_ds_avg.loc[x.index, 'rgi_area_km2'].sum(),#     'B_noirr': lambda x: (x * master_ds_avg.loc[x.index, 'rgi_area_km2']).sum() / master_ds_avg.loc[x.index, 'rgi_area_km2'].sum(),#     'rgi_area_km2': 'sum',  # Sum for area#     'rgi_volume_km3': 'sum',  # Sum for volume#     'V_1985_irr': 'sum',  # Sum for volume#     # 'sample_id': lambda _: "11 member average",#     # take first value for all columns that are not in the list#     **{col: 'first' for col in master_ds.columns if col not in ['B_irr', 'B_noirr','rgi_area_km2','rgi_volume_km3', 'V_1985_irr']}# })master_ds_area_weighted=master_ds_avguse_weights = True# v_space_noi2 = 1.9  # Vertical space between irr and noirr boxplotsv_space_com = 1.6  # Vertical space between irr and noirr boxplotsv_space_hist = 0.4  # Vertical space between irr and noirr boxplotsv_space_com_all = 2.3  # Vertical space between irr and noirr boxplotsv_space_hist_all = 0.1  # Vertical space between irr and noirr boxplots# v_space_irr1 = 0.1  # Vertical space between irr and noirr boxplots# Storage for combined dataall_noirr, all_irr = [], []position_counter = 1cumulative_index = 14# Initialize plotfig = plt.figure(figsize=(16, 6))gs = gridspec.GridSpec(1, 16, width_ratios=[1.5] + [1]*15)  # First axis twice as wide# axes = [fig.add_subplot(gs[i]) for i in range(16)]fig, axes = plt.subplots(1,1, figsize=(16, 6), sharey=True)print(axes)# axes = axes.flatten()p=5.4tick_positions=[]tick_labels=[]mean_list=[]# Example usage: Main loop through regions and subregionsfor r, region in enumerate((regions)):    for sub in range(list((subregions))[r]):        # Filter subregion-specific data        ax = axes        region_id = f"{region}.0{sub+1}"        print(region_id)               subregion_ds = master_ds_area_weighted[master_ds_area_weighted['rgi_subregion'].str.contains(            f"{region}-0{sub+1}")]        # Calculate mean values for Noirr and Irr        # noirr_mean = master_ds_area_weighted['V_2264_noirr'][cumulative_index]        # irr_mean = master_ds_area_weighted['V_2264_irr'][cumulative_index]        # Set color and label based on the region        try:            label = subregion_ds.full_name.iloc[0]        except:            label = f"{region}-0{sub+1}"                if region==13:            if sub ==1:                label = "Pamir"            elif sub ==3:                label = "East Tien Shan"            elif sub ==5:                label = "East Kun Lun"        # Plot Noirr and Irr boxplots        print(position_counter)                tick_positions.append(p +1 )#+ v_space_com -0.2)  # or average of hist + com if you want centered        tick_labels.append(label)                mean_hist = subregion_ds['B_irr'].mean()        mean_noirr = subregion_ds['B_noirr'].mean()         # mean_com_noirr = subregion_ds['V_2264_noirr_delta'].mean()           mean_list.append((region_id, mean_hist, mean_noirr))#, mean_com_noirr))                box_irr, bim = plot_boxplot(            subregion_ds['B_irr'], p + v_space_hist, label, color=colors['irr'][0],colorline=colors['cline_2'][0], alpha=0.4, is_noirr=False)        box_noirr, bnm = plot_boxplot(             subregion_ds['B_noirr'], p + v_space_com, label, color=colors['noirr'][1], colorline=colors['cline_2'][1], alpha=0.8, is_noirr=True)                # box_irr = ax.scatter([p +        #                        v_space_hist], subregion_ds['B_irr'].iloc[0], color=colors['irr'][0], marker="o", s=60, linewidths=3, zorder=10)        # box_irr = ax.scatter([p +        #                        v_space_com], subregion_ds['B_noirr'].iloc[0], color=colors['irr_com'][0], marker="o", s=60, linewidths=3, zorder=10)                ax.text(                p + v_space_hist -0.25,                         # x                bim+60,                 # y                str(int(round(subregion_ds['B_irr'].mean(), 0))),     # text (must be a string!)                rotation=90,                fontsize=12            )                ax.text(                p + v_space_com -0.25,                         # x                bnm+60,                 # y                str(int(round(subregion_ds['B_noirr'].mean(), 0))),     # text (must be a string!)                rotation=90,                fontsize=12            )                ax.text(                p+1, #,+ (v_space_com + v_space_hist)/2 -0.25,                         # x                -1500,                 # y                str(int(round(subregion_ds['B_irr'].mean()-subregion_ds['B_noirr'].mean(), 0))),     # text (must be a string!)                rotation=0,                fontsize=12, ha='center'            )        # ax.hlines(mean_hist,         #   xmin=p + v_space_hist - 0.5,  # adjust width        #   xmax=p + v_space_hist + 0.5,        #   linestyles='dotted',         #   color=colors['cline'][0],        #   linewidth=3,        #   zorder=9)                # ax.hlines(mean_com_noirr,         #   xmin=p + v_space_com - 0.5,  # adjust width        #   xmax=p + v_space_com + 0.5,        #   linestyles='dotted',         #   color=colors['cline'][1],        #   linewidth=3,        #   zorder=9)                # Annotate the number of glaciers and delta between the two columns        num_glaciers = len(master_ds[master_ds.rgi_subregion==f"{region}-0{sub+1}"][master_ds.sample_id=="IPSL-CM6.000"])                # delta = noirr_mean - irr_mean        # Display number of glaciers and delta        initial_volume = round(subregion_ds['V_1985_irr'].iloc[0]*1e-9)        # ax.text(p, y,         #          f'{initial_volume}\n({num_glaciers})',  # \nΔ = {delta:.2f}',        #          va='center', ha='left', fontsize=12, color='black',        #          backgroundcolor="white",  zorder=10)        ax.axvline(p-0.5, color='lightgrey', linestyle='--',                    linewidth=1, zorder=1)         p+=3            # # Plot overall average boxplots for Irr and Noirrp=1.2ax = axes#group by subregion and calculate regional weighted average irr and noirr and total area and volume # master_ds_hma = master_ds_avg.agg({#     'B_irr': lambda x: (x * master_ds_avg.loc[x.index, 'rgi_area_km2']).sum() / master_ds_avg.loc[x.index, 'rgi_area_km2'].sum(),#     'B_noirr': lambda x: (x * master_ds_avg.loc[x.index, 'rgi_area_km2']).sum() / master_ds_avg.loc[x.index, 'rgi_area_km2'].sum(),#     'rgi_area_km2': 'sum',  # Sum for area#     'rgi_volume_km3': 'sum',  # Sum for volume#     'V_1985_irr': 'sum',  # Sum for volume#     # 'sample_id': lambda _: "11 member average",#     # take first value for all columns that are not in the list#     # **{col: 'first' for col in master_ds.columns if col not in ['B_irr', 'B_noirr','rgi_area_km2','rgi_volume_km3', 'V_1985_irr']}# })master_ds_hma=master_ds_avg# avg_irr = ax.scatter([p +                       # v_space_hist_all], master_ds_hma['B_irr'], color=colors['irr'][0], marker="o", s=100, linewidths=4)# avg_irr = ax.scatter([p +                       # v_space_com_all], master_ds_hma['B_noirr'], color=colors['noirr'][0], marker="o", s=100, linewidths=4)avg_irr_hist,bim = plot_boxplot( master_ds_hma['B_irr'], p + v_space_hist_all, [    "High Mountain Asia"], color=colors['irr'][1], colorline=colors['cline_2'][0], alpha=0.8, is_noirr=True)avg_noi_com, bnm = plot_boxplot(master_ds_hma['B_noirr'], p + v_space_com_all, [    "High Mountain Asia"], color=colors['noirr'][1], colorline=colors['cline_2'][1], alpha=0.8, is_noirr=True)ax.text(        p + v_space_hist_all -0.25,                         # x        bim+60,                 # y        str(int(round(master_ds_hma['B_irr'].mean(), 0))),     # text (must be a string!)        rotation=90,        fontsize=12    )ax.text(        p + v_space_com_all -0.25,                         # x        bnm+60,                 # y        str(int(round(master_ds_hma['B_noirr'].mean(), 0))),     # text (must be a string!)        rotation=90,        fontsize=12)ax.text(        p-0.5, #,+ (v_space_com + v_space_hist)/2 -0.25,                         # x        -1500,                 # y        f"∆B$_{{Irr}}$={str(int(round(master_ds_hma['B_irr'].median()-master_ds_hma['B_noirr'].mean(), 0)))}",     # text (must be a string!)        rotation=0,        fontsize=12, ha='left', fontweight='bold'    )        initial_total_volume = round(master_ds_hma['V_1985_irr']*1e-9)# Annotate the number of glaciers for the overall averagelength=len(master_ds[master_ds.sample_id == "CNRM.001"])# ax.text(v_space_hist, y, #          f"V:{initial_total_volume}\n(#:{length})",# Display total number of glaciers#          va='center', ha='left', fontsize=12, color='black',#           backgroundcolor="white", zorder=10)#fontstyle='italic',mean_hist = master_ds_hma['B_irr'].mean()mean_com_irr = master_ds_hma['B_noirr'].mean()# mean_com_noirr = master_ds_hma['V_2264_noirr_delta'].mean()# mean_list.append(("High Mountain Asia", mean_hist, mean_com_irr))# df_means = pd.DataFrame(mean_list, columns=["subregion", "V_2264_irr_delta","V_2264_noirr_delta"])# df_means.to_csv(f"{wd_path}masters/mean_deltaV_Comitted.csv")# Add a legend for regions, mean (dot), and median (stripe)region_legend_patches = [mpatches.Patch(color=colors['irr'][1], label='Historical (W5E5)'),                        mpatches.Patch(color=colors['noirr'][1], label='Historical NoIrr'),                        ]tick_positions.append(1 + v_space_com)tick_labels.append("High\nMountain\nAsia")# Set tick positions and rotated labels (except HMA)ax.set_xticks(tick_positions)ax.set_xticklabels(tick_labels, fontsize=14, rotation=30)# Override HMA rotation to be flat (if needed)for label in ax.get_xticklabels():    if label.get_text() == "High\nMountain\nAsia":        label.set_rotation(0)        label.set_fontweight("bold")        fig.legend(handles=region_legend_patches, loc='upper center',          bbox_to_anchor=(0.28, 0.88), ncols=5, fontsize=14,columnspacing=1.5)ax.set_ylabel('Glacier average mass Balance [mm w.e.]', labelpad=15, fontsize=14)fig.subplots_adjust(wspace=0.1)#, hspace=0.1)ax.set_xlim(0, 3*15+5)ax.tick_params(labelsize=12)# Include the panel plotax.axhline(y=0, color='grey', linestyle='--', linewidth=1, zorder=0)# output_nc_path = os.path.join(wd_path, "masters", "master_comitted_volume_timeseries_individual_member.nc")# # output_nc_path = os.path.join(wd_path, "masters", "master_comitted_volume_timeseries_individual_member_noIPSL.nc")# tlines = xr.open_dataset(output_nc_path)# ax_inset = inset_axes(ax, width="24%", height="32%", loc='lower left',bbox_to_anchor=(286,100,1800, 700))  # width/height can be % or float# for m,model in enumerate(models_shortlist):#     member_series = []#     times = None    #     for x in range(members_averages[m]):#         if x>0:#             ax_inset.plot(#                 tlines.sel(scenario='committed', model=model, member=x, experiment="NoIrr").time.values,#                tlines.sel(scenario='committed', model=model, member=x,experiment="NoIrr").volume_percent-100, ls=':', lw=1, color=colors['noirr_com'][0], zorder=1#             )            #             data = tlines.sel(scenario='committed', model=model, member=x, experiment="NoIrr")#             volume = data.volume_percent - 100#             member_series.append(volume)#             if times is None:#                 times = data.time.values            #     if member_series:#         stacked = xr.concat(member_series, dim='member')#         q25 = stacked.quantile(0.25, dim='member')#         q75 = stacked.quantile(0.75, dim='member')#         # Fill between 25th and 75th percentile#         ax_inset.fill_between(#             times, q25, q75,#             color=colors['noirr_com'][1],#             alpha=0.7,#             zorder=0#         )                                                                # ax_inset.plot(# tlines.sel(scenario='committed', model="W5E5", member=0, experiment="Irr").time.values,# tlines.sel(scenario='committed', model="W5E5", member=0,experiment="Irr").volume_percent-100, ls='-', lw=2, color=colors['irr_com'][0]# )# ax_inset.plot(# tlines.sel(scenario='committed', model="avg", member=0, experiment="NoIrr").time.values,# tlines.sel(scenario='committed', model="avg", member=0,experiment="NoIrr").volume_percent-100, ls='--', lw=2, color=colors['noirr_com'][0], zorder=0# )# # ax_inset.text(0.2, 0.95, "Committed evolution", fontsize=12,# #               transform=ax_inset.transAxes, va='top', ha='left')# # Set axis ticks and labels# ax_inset.set_xlim(2014,2264)# ax_inset.set_xticks([2114, 2214])# ax_inset.set_xticklabels(['100', '200 yrs'])# ax_inset.set_ylim(-30,10)# ax_inset.set_yticks([ 0, -10, -20])#, -30])# ax_inset.set_yticklabels([ '0%', '-10%', '-20%'])#, '-30%'])# # ax_inset.axhline(0, color='grey', linestyle='--', linewidth=1)# # ax_inset.yaxis.label.set_zorder(10)# # Tick marks and labels setup# ax_inset.tick_params(axis='both', which='both',#                      direction='in',     # tick lines point inside#                      length=5,           # visible tick length#                      top=False, bottom=True, left=False, right=True,#                      labelsize=12)# # Tick labels on right side of y-axis# ax_inset.yaxis.set_ticks_position('left')# ax_inset.yaxis.set_label_position("left")# ax_inset.grid(True, axis='both', which='major', linestyle=':', linewidth=0.5, color='gray')# for label in ax_inset.get_xticklabels():#     label.set_verticalalignment('top')#     label.set_y(0.2)  # smaller = closer to axis line (inside)# # Shift y-axis labels left into the plot# for label in ax_inset.get_yticklabels():#     label.set_horizontalalignment('left')#     label.set_x(0.05)  # smaller = closer to axis line (inside)    # rect_x = p + v_space_hist_all + 1.05# rect_y = -24# rect_w=2.25# rect_height=24# square = mpatches.Rectangle((rect_x, rect_y), rect_w, rect_height,#                                linewidth=0.7, edgecolor='black', facecolor='none')# ax.add_patch(square)# rect_x_zoom = 0.2# rect_y_zoom = ylim-110# rect_w_zoom=12# rect_height_zoom=30# square_zoom = mpatches.Rectangle((rect_x_zoom, rect_y_zoom), rect_w_zoom, rect_height_zoom,#                                linewidth=1, edgecolor='none', facecolor='none')# ax.add_patch(square_zoom)# # --- Convert rectangle data coordinates to figure coordinates ---# # Lower left and lower right corners of the rectangle# ll_data = (rect_x, rect_y)# lr_data = (rect_x + rect_w, rect_y)# ll_disp = ax.transData.transform(ll_data)# lr_disp = ax.transData.transform(lr_data)# ll_fig = fig.transFigure.inverted().transform(ll_disp)# lr_fig = fig.transFigure.inverted().transform(lr_disp)# # --- Get upper left and right of the inset in figure coordinates ---# # These are in the inset's axes coordinates, so (0, 1) is upper-left, (1, 1) is upper-right# ul_data_zoom = (rect_x_zoom, rect_y_zoom+rect_height_zoom)# ur_data_zoom = (rect_x_zoom + rect_w_zoom, rect_y_zoom+rect_height_zoom)# ul_disp_zoom = ax.transData.transform(ul_data_zoom)# ur_disp_zoom = ax.transData.transform(ur_data_zoom)# ul_fig_zoom = fig.transFigure.inverted().transform(ul_disp_zoom)# ur_fig_zoom = fig.transFigure.inverted().transform(ur_disp_zoom)# # --- Draw lines from rectangle to inset corners ---# line_left = mlines.Line2D([ll_fig[0], ul_fig_zoom[0]], [ll_fig[1], ul_fig_zoom[1]],#                           transform=fig.transFigure, color='black', linestyle='--', zorder=10, lw=0.7)# line_right = mlines.Line2D([lr_fig[0], ur_fig_zoom[0]], [lr_fig[1], ur_fig_zoom[1]],#                            transform=fig.transFigure, color='black', linestyle='--', zorder=10, lw=0.7)# ax.grid(True, axis='y', which='major', linestyle=':', linewidth=0.5, color='gray')# fig.lines.extend([line_left, line_right])plt.savefig(    f"{fig_path}/Boxplot_Mass_Balance_Extended_Data_mean.png")plt.show()            #%% Cell 5: Annual runoff timeline plot HMA melt or runoff onlydef annual_runoff_timeline_plot_hma(nr_months, runoff_components, ax=None):    peak_water_dict={}    peak_water_list=[]    plotting_subregions='off' #specify if one plot or also subplots    #when working with melton only    opath_df_monthly_melt = os.path.join(wd_path,'masters','hydro_output_monthly_subregions_melton_only.csv')    opath_df_annual_melt = os.path.join(wd_path,'masters','hydro_output_annual_subregions_melton_only.csv')        #when working with melton and prcp on only    # opath_df_monthly = os.path.join(wd_path,'masters','hydro_output_monthly_subregions_meltprcpon_only.csv')    # opath_df_annual = os.path.join(wd_path,'masters','hydro_output_annual_subregions_meltprcpon_only.csv')    #     #when working with total runoff    opath_df_monthly = os.path.join(wd_path,'masters','hydro_output_monthly_subregions.csv')    opath_df_annual = os.path.join(wd_path,'masters','hydro_output_annual_subregions.csv')        opath_df_runoff_shares = os.path.join(wd_path,'masters','hydro_output_monthly_runoff_shares.csv')        #load annual data for all runoff    df_annual = pd.read_csv(opath_df_annual).reset_index()    df_monthly = pd.read_csv(opath_df_monthly, dtype={'ssp': str, 'rgi_subregion': str, 'experiment': str})[['year','month','experiment','ssp','member', 'runoff','rgi_subregion']]        #load annual data for only melt    df_annual_melt = pd.read_csv(opath_df_annual_melt).reset_index()    df_monthly_melt = pd.read_csv(opath_df_monthly_melt, dtype={'ssp': str, 'rgi_subregion': str, 'experiment': str})[['year','month','experiment','ssp','member', 'runoff','rgi_subregion']]         #process data for total runoff                      # df_avg_monthly = (df_monthly.groupby(['year','month', 'experiment', 'ssp', 'rgi_subregion',])['runoff'].mean().reset_index()) #average over members    df_avg_monthly = (df_monthly.groupby(['year','month', 'experiment', 'ssp', 'rgi_subregion',])['runoff'].median().reset_index()) #average over members    df_avg_monthly = df_avg_monthly[df_avg_monthly['runoff'] != 0.00] #exclude zeros as last year of simulation does not work    #     if nr_months == 12:        df_avg_jja = df_avg_monthly[df_avg_monthly['month'].isin(np.arange(1,13,1))] #if we want full year    else:        df_avg_jja = df_avg_monthly[df_avg_monthly['month'].isin([6, 7, 8])]    df_avg_subregions = (df_avg_jja.groupby(['year', 'experiment', 'ssp', 'rgi_subregion'])['runoff'].sum().reset_index()) #sum yo annual runoff for all subregions per year    df_avg_subregions = df_avg_subregions[~df_avg_subregions['year'].isin([2074])]     df_avg_all = (df_avg_subregions.groupby(['year', 'experiment', 'ssp'])['runoff'].sum().reset_index()) #sum for all subregions in HMA        df_monthly_std_in = df_monthly[df_monthly['runoff'] != 0.00] #exclude zeros as last year of simulation does not work    df_avg_monthly_for_std = (df_monthly_std_in.groupby(['year', 'experiment', 'ssp', 'member'])['runoff'].sum().reset_index()) #calculate annual sum of runoff for the different members for hma overall    df_avg_monthly_for_std = df_avg_monthly_for_std[~df_avg_monthly_for_std['year'].isin([2074])]     df_avg_annual_std_all = (df_avg_monthly_for_std.groupby(['year', 'experiment', 'ssp'])['runoff'].std().reset_index()) #take std before rolling mean (otherwise std is smoothened too much, losing variability)    df_avg_annual_std_all['runoff'] = df_avg_annual_std_all['runoff'].fillna(0) #hist irr is nan because only 1 member - make zero for plotting            #process data for melt only runoff    # df_avg_monthly_melt = (df_monthly_melt.groupby(['year','month', 'experiment', 'ssp', 'rgi_subregion',])['runoff'].mean().reset_index()) #average over members    df_avg_monthly_melt = (df_monthly_melt.groupby(['year','month', 'experiment', 'ssp', 'rgi_subregion',])['runoff'].median().reset_index()) #median over members    df_avg_monthly_melt = df_avg_monthly_melt[df_avg_monthly_melt['runoff'] != 0.00]        if nr_months == 12:        df_avg_jja_melt = df_avg_monthly_melt[df_avg_monthly_melt['month'].isin(np.arange(1,13,1))] #if we want full year    else:        df_avg_jja_melt = df_avg_monthly_melt[df_avg_monthly_melt['month'].isin([6, 7, 8])]    df_avg_subregions_melt = (df_avg_jja_melt.groupby(['year', 'experiment', 'ssp', 'rgi_subregion'])['runoff'].sum().reset_index()) #sum yo annual runoff for all subregions per year    df_avg_subregions_melt = df_avg_subregions_melt[~df_avg_subregions_melt['year'].isin([2074])]     df_avg_all_melt = (df_avg_subregions_melt.groupby(['year', 'experiment', 'ssp'])['runoff'].sum().reset_index()) #sum for all subregions in HMA        df_monthly_std_in_melt = df_monthly_melt[df_monthly_melt['runoff'] != 0.00] #exclude zeros as last year of simulation does not work    df_avg_monthly_for_std_melt = (df_monthly_std_in_melt.groupby(['year', 'experiment', 'ssp', 'member'])['runoff'].sum().reset_index()) #calculate annual sum of runoff for the different members for hma overall    df_avg_monthly_for_std_melt = df_avg_monthly_for_std_melt[~df_avg_monthly_for_std_melt['year'].isin([2074])]     df_avg_annual_std_all_melt = (df_avg_monthly_for_std_melt.groupby(['year', 'experiment', 'ssp'])['runoff'].std().reset_index()) #take std before rolling mean (otherwise std is smoothened too much, losing variability)    df_avg_annual_std_all_melt['runoff'] = df_avg_annual_std_all_melt['runoff'].fillna(0) #hist irr is nan because only 1 member - make zero for plotting        if plotting_subregions =='on':        if ax==None:            fig,axes = plt.subplots(4,4,figsize=(12,8), sharex=True, sharey=False) #if including subregions            ax = axes.flatten()                        c=1                lw_tot=3 #specify linethickness for items        lw_melt=1                """ Plotting for subregions """                                                for region in df_avg_subregions['rgi_subregion'].unique():            print(region)            region_data = df_avg_subregions[df_avg_subregions['rgi_subregion'] == region] #check if glacier is in region            region_data_melt = df_avg_subregions_melt[df_avg_subregions_melt['rgi_subregion'] == region] #check if glacier is in region                        #calculate relative runoff            base_year = region_data[region_data['year']==1985][region_data['experiment']=='irr'].runoff.values            region_data['runoff_relative']=((region_data['runoff']-base_year)/base_year)                        base_year_melt = region_data[region_data['year']==1985][region_data['experiment']=='irr'].runoff.values            region_data_melt['runoff_relative']=((region_data_melt['runoff']-base_year)/base_year) #respective to 1985 total runoff            # region_data_melt['runoff_relative']=((region_data_melt['runoff']-base_year_melt)/base_year_melt) #respective to 1985 melt only runoff                        # calculate cumulative absolute total runoff            # region_data['runoff_cumulative'] = region_data.sort_values([ 'year']).groupby([ 'experiment', 'ssp'])['runoff'].cumsum() #sorting as years need to be in order for accumulation                        # for (exp, ssp) in region_data.groupby(['experiment', 'ssp']).groups.keys():            #     # Skip 'hist' by itself — only process SSPs and combine with hist timeseries            #     if ssp == 'hist':            #         continue             #     # if ssp=='126':            #         # continue                    #     # Define index for colors or line styles            #     add = "_fut"            #     s = 0 if ssp == "126" else 1                    #     # Combine hist + this SSP for the same experiment            #     hist_ssp = region_data[(region_data['experiment'] == exp) &(region_data['ssp'].isin(['hist', ssp]))].copy()            #     hist_ssp_melt = region_data_melt[(region_data_melt['experiment'] == exp) &(region_data_melt['ssp'].isin(['hist', ssp]))].copy()                    #     # Sort by time            #     hist_ssp = hist_ssp.sort_values('year')            #     hist_ssp_melt = hist_ssp_melt.sort_values('year')                            #     # Smooth            #     hist_ssp['runoff_smoothed'] = (hist_ssp['runoff'].rolling(window=11, center=True, min_periods=1).mean())            #     hist_ssp_melt['runoff_smoothed'] = (hist_ssp_melt['runoff'].rolling(window=11, center=True, min_periods=1).mean())                                    #     # hist_ssp['relative_runoff_smoothed'] = (hist_ssp['runoff_relative'].rolling(window=11, center=True, min_periods=1).mean())            #     # hist_ssp_melt['relative_runoff_smoothed'] = (hist_ssp_melt['runoff_relative'].rolling(window=11, center=True, min_periods=1).mean())                    #     # Style settings            #     ls = '--' if exp == "noi" else '-'            #     # lw = 1 if exp == "noi" else 2                    #     # Split into historical & future            #     is_hist = hist_ssp['year'] < 2014            #     is_future = hist_ssp['year'] >= 2014                    #     # Plot hist part (no add)            #     ax[c].plot(            #         hist_ssp.loc[is_hist, 'year'],            #         hist_ssp.loc[is_hist, 'relative_runoff_smoothed']*100,            #         # hist_ssp.loc[is_hist, 'runoff_cumulative'],            #         # hist_ssp.loc[is_hist, 'runoff_smoothed'],            #         label=f"{exp.upper()} hist",            #         color=colors[f'{exp}'][0],            #         linestyle=ls, linewidth=lw_tot,             #     )                            #     ax[c].plot(            #         hist_ssp_melt.loc[is_hist, 'year'],            #         hist_ssp_melt.loc[is_hist, 'relative_runoff_smoothed']*100,            #         # hist_ssp_melt.loc[is_hist, 'runoff_cumulative'],            #         # hist_ssp_melt.loc[is_hist, 'runoff_smoothed'],            #         label=f"{exp.upper()} hist",            #         color=colors[f'{exp}'][0],            #         linestyle=ls, linewidth=lw_melt            #     )                    #     # Plot future part (add)            #     ax[c].plot(            #         hist_ssp.loc[is_future, 'year'],            #         hist_ssp.loc[is_future, 'relative_runoff_smoothed']*100,            #         # hist_ssp.loc[is_future, 'runoff_cumulative'],            #         # hist_ssp.loc[is_future, 'runoff_smoothed'],            #         label=f"{exp.upper()} {ssp}",            #         color=colors[f'{exp}{add}'][s],            #         linestyle=ls, linewidth=lw_tot            #     )                            #     ax[c].plot(            #         hist_ssp_melt.loc[is_future, 'year'],            #         hist_ssp_melt.loc[is_future, 'relative_runoff_smoothed']*100,            #         # hist_ssp_melt.loc[is_future, 'runoff_cumulative'],            #         # hist_ssp_melt.loc[is_future, 'runoff_smoothed'],            #         label=f"{exp.upper()} {ssp}",            #         color=colors[f'{exp}{add}'][s],            #         linestyle=ls, linewidth=lw_melt            #     )                            #     peak_year=hist_ssp.loc[hist_ssp['runoff_smoothed'].idxmax(), 'year']            #     peak_magnitude=hist_ssp.loc[hist_ssp['runoff_smoothed'].idxmax(), 'runoff_smoothed']                                                            #     peak_water_dict = {            #         'rgi_subregion':region,            #         'peak_water_year': peak_year,            #         'peak_magnitude': peak_magnitude,            #         'experiment': exp,            #         'ssp': ssp}                            #     peak_water_list.append(peak_water_dict)            #     # print(peak_water_dict)                            #     if peak_year<=2014:            #         color='black'            #     else:            #         color=colors[f'{exp}{add}'][s]            #     ax[c].axvline(peak_year, color=color, linestyle=ls, lw=lw_tot-2)            #     ax[c].set_title(f'Region: {region}')                    # ax[c].set_title(f'Region: {region}')            # ax[c].grid(True, color='grey', ls='--', lw=0.5)                        # plt.tight_layout()            # c+=1    else:        if ax==None:            fig,ax = plt.subplots(1,1, figsize=(12,8), sharex=True, sharey=False)        lw_tot=3        lw_melt=2            if plotting_subregions=='on':        # if ax==None:        ax = ax[0] #otherwise subscript problems                    base_year_all =df_avg_all[df_avg_all['year']==1985][df_avg_all['experiment']=='irr'].runoff.values    #calculate relative runoff    df_avg_all['runoff_relative']=(df_avg_all['runoff']-base_year_all)/base_year_all    df_avg_annual_std_all['runoff_relative']=(df_avg_annual_std_all['runoff'])/base_year_all        base_year_all_melt =df_avg_all_melt[df_avg_all_melt['year']==1985][df_avg_all_melt['experiment']=='irr'].runoff.values    df_avg_all_melt['runoff_relative']=(df_avg_all_melt['runoff']-base_year_all)/base_year_all #relative to total runoff    # df_avg_all_melt['runoff_relative']=(df_avg_all_melt['runoff']-base_year_all)/base_year_all_melt #relative to total runoff        for (exp, ssp) in df_avg_all.groupby(['experiment', 'ssp']).groups.keys():                # Skip 'hist' by itself — only process SSPs        if ssp == 'hist':            continue        # if ssp=='126':            # continue            # Define index for colors or line styles        add = "_fut"        s = 0 if ssp == "126" else 1            # Combine hist + this SSP for the same experiment        hist_ssp = df_avg_all[(df_avg_all['experiment'] == exp) & (df_avg_all['ssp'].isin(['hist', ssp]))].copy()        hist_ssp_melt = df_avg_all_melt[(df_avg_all_melt['experiment'] == exp) & (df_avg_all_melt['ssp'].isin(['hist', ssp]))].copy()        hist_ssp_std = df_avg_annual_std_all[(df_avg_annual_std_all['experiment'] == exp) & (df_avg_annual_std_all['ssp'].isin(['hist', ssp]))].copy()        hist_ssp_std_melt = df_avg_annual_std_all_melt[(df_avg_annual_std_all_melt['experiment'] == exp) & (df_avg_annual_std_all_melt['ssp'].isin(['hist', ssp]))].copy()            # Sort by time        hist_ssp = hist_ssp.sort_values('year')        hist_ssp_melt = hist_ssp_melt.sort_values('year')            hist_ssp_std = hist_ssp_std.sort_values('year')        hist_ssp_std_melt = hist_ssp_std_melt.sort_values('year')                    #calculate cumulative absolute total runoff        hist_ssp['runoff_cumulative'] = hist_ssp.sort_values(['year']).groupby(['experiment'])['runoff'].cumsum() #sorting as years need to be in order for accumulation        hist_ssp_melt['runoff_cumulative'] = hist_ssp_melt.sort_values(['year']).groupby(['experiment'])['runoff'].cumsum() #sorting as years need to be in order for accumulation            # Smooth        hist_ssp['runoff_smoothed'] = (hist_ssp['runoff'].rolling(window=11, center=True, min_periods=1).mean())        hist_ssp_melt['runoff_smoothed'] = (hist_ssp_melt['runoff'].rolling(window=11, center=True, min_periods=1).mean())        hist_ssp_std['runoff_smoothed'] = (hist_ssp_std['runoff'].rolling(window=11, center=True, min_periods=1).mean())        hist_ssp_std_melt['runoff_smoothed'] = (hist_ssp_std_melt['runoff'].rolling(window=11, center=True, min_periods=1).mean())                hist_ssp['relative_runoff_smoothed'] = (hist_ssp['runoff_relative'].rolling(window=11, center=True, min_periods=1).mean())        hist_ssp_std['relative_runoff_smoothed'] = (hist_ssp_std['runoff_relative'].rolling(window=11, center=True, min_periods=1).mean())        hist_ssp_melt['relative_runoff_smoothed'] = (hist_ssp_melt['runoff_relative'].rolling(window=11, center=True, min_periods=1).mean())                # hist_ssp['cumulative_runoff_smoothed'] = (hist_ssp['runoff_cumulative'].rolling(window=11, center=True, min_periods=1).mean())        # hist_ssp_melt['cumulative_runoff_smoothed'] = (hist_ssp_melt['runoff_cumulative'].rolling(window=11, center=True, min_periods=1).mean())            # Style settings        print(exp)        ls = '--' if exp == "noi" else '-'        # lw = 1 if exp == "noi" else 2            # Split into historical & future        is_hist = hist_ssp['year'] < 2014        is_future = hist_ssp['year'] >= 2014                #plot shading first        #plot std hist                if exp=='noi':            exp="noirr"                #plot std hist melt        if runoff_components=='melt_only':                        if exp=='irr' and ssp=='126':                ax.text(1983, hist_ssp_melt.loc[is_hist, 'runoff_smoothed'].iloc[0] + 15000, 'Melt only', fontweight='medium', fontsize=14)                                                ax.fill_between(                hist_ssp_melt.loc[is_hist, 'year'],                hist_ssp_melt.loc[is_hist, 'runoff_smoothed']-hist_ssp_std_melt.loc[is_hist, 'runoff_smoothed'],                hist_ssp_melt.loc[is_hist, 'runoff_smoothed']+hist_ssp_std_melt.loc[is_hist, 'runoff_smoothed'],                 label=f"{exp.upper()} hist",color=colors[f'{exp}'][0],                linestyle=ls, linewidth=lw_melt, alpha=0.1                 )                        # plot std future melt            ax.fill_between(                hist_ssp_melt.loc[is_future, 'year'],                hist_ssp_melt.loc[is_future, 'runoff_smoothed']-hist_ssp_std_melt.loc[is_future, 'runoff_smoothed'],                hist_ssp_melt.loc[is_future, 'runoff_smoothed']+hist_ssp_std_melt.loc[is_future, 'runoff_smoothed'],                 label=f"{exp.upper()} hist",color=colors[f'{exp}{add}'][s],                linestyle=ls, linewidth=lw_melt, alpha=0.1                 )                        # Plot hist part melt (no add)            ax.plot(                hist_ssp_melt.loc[is_hist, 'year'],                # hist_ssp.loc[is_hist, 'relative_runoff_smoothed']*100,                # hist_ssp.loc[is_hist, 'runoff_cumulative'],                hist_ssp_melt.loc[is_hist, 'runoff_smoothed'],                label=f"{exp.upper()} hist",                color=colors[f'{exp}'][0],                linestyle=ls, linewidth=lw_melt)                        # Plot future part melt (add)            ax.plot(                hist_ssp_melt.loc[is_future, 'year'],                # hist_ssp_melt.loc[is_future, 'relative_runoff_smoothed']*100,            #     # hist_ssp_melt.loc[is_future, 'runoff_cumulative'],                hist_ssp_melt.loc[is_future, 'runoff_smoothed'],                label=f"{exp.upper()} {ssp}",                color=colors[f'{exp}{add}'][s],                linestyle=ls, linewidth=lw_melt            )                        peak_year=hist_ssp_melt.loc[hist_ssp_melt['runoff_smoothed'].idxmax(), 'year']            peak_magnitude=hist_ssp_melt.loc[hist_ssp_melt['runoff_smoothed'].idxmax(), 'runoff_smoothed']            print(peak_year)            if peak_year<=2014:                color='black'            else:                color=colors[f'{exp}{add}'][s]            face_color='none' if exp=='noirr' else color            # ax.axvline(peak_year, color=color, linestyle=ls, lw=lw_tot-2)            ax.scatter(peak_year, peak_magnitude ,marker='o', s=100, facecolor=face_color, edgecolor=color, linewidths=3, zorder=100)  # thicker edge)            # ax.text(peak_year, peak_magnitude ,marker='o', s=100, facecolor=face_color, edgecolor=color, linewidths=5)  # thicker edge)                                        if runoff_components=='total_runoff':            # Plot hist part (no add)            ax.plot(                hist_ssp.loc[is_hist, 'year'],                # hist_ssp.loc[is_hist, 'relative_runoff_smoothed']*100,                # hist_ssp.loc[is_hist, 'runoff_cumulative'],                hist_ssp.loc[is_hist, 'runoff_smoothed'],                label=f"{exp.upper()} hist",                color=colors[f'{exp}'][0],                linestyle=ls, linewidth=lw_tot                   )                        if exp=='irr' and ssp=='126':                ax.text(1983, hist_ssp.loc[is_hist, 'runoff_smoothed'].iloc[0] + 15000, 'Total', fontweight='medium', fontsize=14)                    ax.fill_between(                hist_ssp.loc[is_hist, 'year'],                hist_ssp.loc[is_hist, 'runoff_smoothed']-hist_ssp_std.loc[is_hist, 'runoff_smoothed'],                hist_ssp.loc[is_hist, 'runoff_smoothed']+hist_ssp_std.loc[is_hist, 'runoff_smoothed'],                 label=f"{exp.upper()} hist",color=colors[f'{exp}'][0],                linestyle=ls, linewidth=lw_tot, alpha=0.1                 )                        #plot std future            ax.fill_between(                hist_ssp.loc[is_future, 'year'],                hist_ssp.loc[is_future, 'runoff_smoothed']-hist_ssp_std.loc[is_future, 'runoff_smoothed'],                hist_ssp.loc[is_future, 'runoff_smoothed']+hist_ssp_std.loc[is_future, 'runoff_smoothed'],                 label=f"{exp.upper()} hist",color=colors[f'{exp}{add}'][s],                linestyle=ls, linewidth=lw_tot, alpha=0.1             )                        # Plot future part (add)            ax.plot(                hist_ssp.loc[is_future, 'year'],                # hist_ssp.loc[is_future, 'relative_runoff_smoothed']*100,                # hist_ssp.loc[is_future, 'runoff_cumulative'],                hist_ssp.loc[is_future, 'runoff_smoothed'],                label=f"{exp.upper()} {ssp}",                color=colors[f'{exp}{add}'][s],                linestyle=ls, linewidth=lw_tot            )                        peak_year=hist_ssp.loc[hist_ssp['runoff_smoothed'].idxmax(), 'year']            peak_magnitude=hist_ssp.loc[hist_ssp['runoff_smoothed'].idxmax(), 'runoff_smoothed']            if peak_year<=2014:                color='black'            else:                color=colors[f'{exp}{add}'][s]            face_color='none' if exp=='noirr' else color            # ax.axvline(peak_year, color=color, linestyle=ls, lw=lw_tot-2)            ax.scatter(peak_year, peak_magnitude,marker='o', s=100, facecolor=face_color, edgecolor=color, linewidths=3, zorder=100)  # thicker edge)                        #Plot std for relative           # ax.fill_between(           #     hist_ssp.loc[is_hist, 'year'],           #     hist_ssp.loc[is_hist, 'relative_runoff_smoothed']*100-hist_ssp_std.loc[is_hist, 'relative_runoff_smoothed']*100,           #     hist_ssp.loc[is_hist, 'relative_runoff_smoothed']*100+hist_ssp_std.loc[is_hist, 'relative_runoff_smoothed']*100,            #     label=f"{exp.upper()} hist",color=colors[f'{exp}{add}'][s],           #     linestyle=ls, linewidth=lw_tot, alpha=0.1                # )                        #Plot std for relative            # ax.fill_between(            #     hist_ssp.loc[is_future, 'year'],            #     hist_ssp.loc[is_future, 'relative_runoff_smoothed']*100-hist_ssp_std.loc[is_future, 'relative_runoff_smoothed']*100,            #     hist_ssp.loc[is_future, 'relative_runoff_smoothed']*100+hist_ssp_std.loc[is_future, 'relative_runoff_smoothed']*100,             #     label=f"{exp.upper()} hist",color=colors[f'{exp}{add}'][s],            #     linestyle=ls, linewidth=lw_tot, alpha=0.1                 # )                if ax==None: #set figure labels later in overall figure        fig.text(            0.5,  # to the right            -0.02,         # middle of whisker            'Years',            va='center',            ha='left',            fontsize=12,            # fontweight='bold',                    )                fig.text(            -0.01,  # to the right            0.5,         # middle of whisker            # 'Total annual runoff [km$^3$]',            # 'Total cumulative annual runoff [km$^3$]',            'Total annual runoff change [%]',            va='center',            ha='left',            fontsize=12,            # fontweight='bold'            rotation=90        )        if ax==None:        ax.set_title('High Mountain Asia', fontweight='bold')    ax.grid(True, color='grey', ls='--', lw=0.5)        linestyle_patches = [        mlines.Line2D([0], [0], color='grey', linestyle='-',linewidth=lw_tot,label='Total runoff'),        mlines.Line2D([0], [0], color='grey', linestyle='--',linewidth=lw_tot,label='Total runoff NoIrr'),        mlines.Line2D([0], [0], color='grey', linestyle='-',linewidth=lw_melt,label='Melt'),        mlines.Line2D([0], [0], color='grey', linestyle='--',linewidth=lw_melt,label='Melt NoIrr'),            ]        # Line legend (your original)    line_patches = [        mpatches.Patch(color=colors['irr'][0], label='Historical (W5E5)'),        mpatches.Patch(color=colors['noirr'][0], label='Historical NoIrr'),        mpatches.Patch(color=colors['irr_fut'][0], label='Future (CESM2), SSP-1.26'),        mpatches.Patch(color=colors['noirr_fut'][0], label='Future NoIrr, SSP-1.26'),        mpatches.Patch(color=colors['irr_fut'][1], label='Future (CESM2), SSP-3.70'),        mpatches.Patch(color=colors['noirr_fut'][1], label='Future NoIrr, SSP-3.70'),            ]        # Combine them    legend_patches =  line_patches + linestyle_patches         # Add to figure/axes    if ax==None: #only set legend if single figure        fig.legend(handles=legend_patches, loc='lower center', frameon=False, ncols=5, bbox_to_anchor=(0.5,-0.14))    else:        if ax == axes_tot[0]:            index = 'a'            title="Annual Runoff"        elif ax == axes_tot[1]:            index = 'b'            title="Summer Runoff"        else:            index=''            title=''        # elif ax == axes_tot[2]:        #     index = 'c.'        # else:        #     index = 'd.'        ax.text(0.95,0.95, index, transform=ax.transAxes,fontweight='bold', fontsize=14)        ax.text(0.03,0.95, title, transform=ax.transAxes,fontweight='bold', fontsize=14)        # plt.xlabel('Year')    # plt.ylabel('Runoff [km³]')    # plt.legend()    # plt.show()    opath_dict_pw = os.path.join(wd_path,'masters','hydro_peak_water_dictionary_subregions.csv')    df = pd.DataFrame(peak_water_list)    # df.to_csv(opath_dict_pw, index=False) #only run when subregions on    return ax# ax_timeline =  annual_runoff_timeline_plot_hma()# ax_timeline.show()annual_runoff_timeline_plot_hma(12, 'total_runoff')#%% Cell 6: Make stacked figure with melt annual runoff and full year/3 months onlyfig_tot, axes_tot = plt.subplots(1,2, figsize=(16,8), constrained_layout=False, sharex=True, sharey=True, gridspec_kw={'wspace': 0.05}  )  # bottom plot = 2x height)axes_tot = axes_tot.flatten()annual_runoff_timeline_plot_hma(12, 'total_runoff', ax=axes_tot[0]) #plot future glacier volume evolutionaxes_tot[0].set_ylabel('Runoff [m$^3$/yr]', fontsize=14)annual_runoff_timeline_plot_hma(12, 'melt_only', ax=axes_tot[0]) #plot future glacier volume evolution# axes_tot[1].set_ylabel('Full year melt [m$^3$]', fontsize=14)annual_runoff_timeline_plot_hma(3, 'total_runoff', ax=axes_tot[1]) #plot future glacier volume evolution# axes_tot[0].set_ylabel('Summer runoff [m$^3$]', fontsize=14)annual_runoff_timeline_plot_hma(3, 'melt_only', ax=axes_tot[1]) #plot future glacier volume evolution# axes_tot[1].set_ylabel('Summer melt [m$^3$]', fontsize=14)axes_tot[0].ticklabel_format(axis='y', style='sci', scilimits=(3,3))axes_tot[0].tick_params(axis='both', labelsize=14)axes_tot[1].tick_params(axis='both', labelsize=14)# peak_water_scatter_plot(ax=axes_tot[2])# axes_tot[2].set_title('c. Average peak water', fontweight='bold', loc='right')# axes_tot[2].set_ylabel('Subregions', fontsize=14)fig_tot.text(0.5,0.04,'Years', fontsize=14)line_patches = [    mlines.Line2D([], [], color="darkgrey", linestyle='-', linewidth=2,                  label='Irrigation'),    mlines.Line2D([], [], color="lightgrey", linestyle='--', linewidth=2,                  label='No Irrigation'),]color_patches = [mpatches.Patch(color=colors['irr'][0], label='Historical (W5E5)    '),                  mpatches.Patch(color=colors['irr_fut'][0], linestyle='-', linewidth=2,                               label='Future (CESM2), SSP-1.26'),                 mpatches.Patch(color=colors['irr_fut'][1], linestyle='-', linewidth=2,                               label='Future (CESM2), SSP-3.70')]                 scatter_patches = [Line2D([0], [0], marker='o', lw=0,  markerfacecolor='grey', markeredgecolor='grey', mew=3, markersize=10, label='Peakwater Irr'),                  Line2D([0], [0], marker='o', lw=0, markerfacecolor='none', markeredgecolor='grey', mew = 3, markersize=10, label='Peakwater NoIrr')]legend_patches = color_patches + line_patches + scatter_patchesaxes_tot[1].legend(handles=legend_patches, loc='upper left', bbox_to_anchor=(0,0.95), ncols=1, frameon=False, fontsize=14)#,    #%% Cell 7: Map plot PT onlydef map_plot_onevar_only(var, fig, ax=None):    wd_path = f'{folder_path}/04. Modelled perturbation-glacier interactions - R13-15 A+1km2/'    # wd_path = f'{folder_path}/03. Modelled perturbation-glacier interactions - R13-15 A+5km2/'        members_averages = [2, 3,  3,  5, 1]    models_shortlist = ["E3SM", "CESM2",  "NorESM",  "CNRM", "IPSL-CM6"]            """ Load data"""    aggregated_ds = pd.read_csv(        f"{wd_path}masters/complete_master_processed_for_map_plot_{var}_only.csv")        # aggregated_ds_vol = pd.read_csv(    #     f"{wd_path}masters/delta_volume_evolution_ensemble_average_{var}_only.csv")        gdf = gpd.GeoDataFrame(aggregated_ds, geometry=gpd.points_from_xy(        aggregated_ds['lon'] +0.5 , aggregated_ds['lat'] + 0.5),        crs="EPSG:4326")        # gdf_volume = gpd.GeoDataFrame(aggregated_ds_vol, geometry=gpd.points_from_xy(    #     aggregated_ds_vol['lon'] +0.5 , aggregated_ds_vol['lat'] + 0.5),    #     crs="EPSG:4326")        """ Plot shaded relief """    if ax==None:        fig, ax = plt.subplots(figsize=(15,12), subplot_kw={                           'projection': ccrs.PlateCarree()})            dem_path = "/Users/magaliponds/Library/CloudStorage/OneDrive-VrijeUniversiteitBrussel/1. VUB/02. Research/01. IRRMIP/03. Data/01. Input files/02. DEM/ETOPO2v2c_f4.nc"    with xr.open_dataset(dem_path) as ds:        dem=ds['z']        # Print dataset info to find variable names        # dem = dem.where((dem.x >= 54.5) & (dem.x <= 115) & (dem.y >= 16) & (dem.y <= 55), drop=True)    dem = dem.where((dem.x >= 65.5) & (dem.x <= 108) & (dem.y >= 23) & (dem.y <= 48), drop=True)    dx =(dem['x'][1]-dem['x'][0]).values    dy =(dem['y'][1]-dem['y'][0]).values    z = dem.values    x, y = np.meshgrid(dem.x, dem.y)        # Create a LightSource object for hillshading    ls = LightSource(azdeg=315, altdeg=45)            # Overlay the hillshade (for relief effect)    im = ax.imshow(ls.hillshade(z, vert_exag=10, dx=0.01, dy=0.01),extent=[dem.x.min(), dem.x.max(), dem.y.min(), dem.y.max()],              transform=ccrs.PlateCarree(), alpha=0.1, cmap="grey_r")  # Adjust alpha for effect        # Add geographical features    # ax.add_feature(cfeature.COASTLINE, linewidth=0.7)    # ax.add_feature(cfeature.BORDERS, linewidth=0.5, linestyle="--")    # ax.add_feature(cfeature.LAND, edgecolor='black', facecolor='none')    ax.add_feature(cfeature.RIVERS, edgecolor='blue', facecolor='none', linewidth=0.6, alpha=0.6)        """Set up plot incl shapefile"""            subregions_path = "/Users/magaliponds/Library/CloudStorage/OneDrive-VrijeUniversiteitBrussel/1. VUB/02. Research/01. IRRMIP/03. Data/02. QGIS/RGI outlines/GTN-G_O2regions_selected_clipped.shp"    subregions = gpd.read_file(subregions_path).to_crs('EPSG:4326')    ax.spines['geo'].set_visible(True)        # Optionally, remove gridlines    # Remove gridlines properly    gl = ax.gridlines(draw_labels=False)  # Create gridlines without labels    gl.xlines = False  # Remove longitude lines    gl.ylines = False  # Remove latitude lines            """ Plot subregions"""    # define movements for the annotation of subregions    movements = {        '13-01': [0, -0.2], #A        '13-02': [4.8, 2], #        '13-03': [-0.2, -0.6], #B        '13-04': [-0.6, 0], #C        '13-05': [-4.6,2.5],#-0.2, 0.8], #E        '13-06': [-10, 0], #F        '13-07': [-1, 1], #G        '13-08': [-2, -0.5], #J        '13-09': [1.5, 0], #O        '14-01': [0.5, -0.8], #H        '14-02': [2,-1.8],#[1, -0.4], #I        '14-03': [3.4, -3.5], #K        '15-01': [0, 0], #L        '15-02': [-2, -1], #M        '15-03': [3.5, 4.5], #N    }    # annotate subregions    # i=0           # Create a ListedColormap with some colors (example)    """ Include the Mass Balance plot including color bar"""        h_leg = 0.65    w_leg = 0.646        # if var=="T":    # cax = fig.add_axes([0.11, 0.125, 0.015, 0.07])  # [left, bottom, width, height]    cax = fig.add_axes([0.11, 0.125, 0.02, 0.09])  # [left, bottom, width, height]#     # cax = fig.add_axes([0.76, h_leg-0.015, 0.03, 0.06])  # [left, bottom, width, height]        scatter_data = "B"        # Define vmin and vmax for the color scale (asymmetric)    vmin, vmax = -0.2, 0.7  # Asymmetric range    start =(abs(vmin)/(vmax-vmin))    #Trim cmap so that white is at 0    n_colors=256    half=n_colors//2    original_cmap = plt.cm.bwr.reversed()  # Blue-White-Red colormap        colors_trimmed = [        (0.0,  "#fdc1c5"),   # Light red at far negative        (0.222, "white"),    # White at 0        (0.5, "#6a79f7"),   # Deep blue at moderate positive #0203e2 0.65 limit before        (1.0,  "#110954")    # Purple at strong positive        ]        # Create custom colormap    custom_cmap = LinearSegmentedColormap.from_list("custom_trimmed_rwb", colors_trimmed, N=256)            # Create the colorbar    cbar = plt.colorbar(plt.cm.ScalarMappable(norm=norm,cmap=custom_cmap ),                        cax=cax, orientation="vertical")        # Define **evenly spaced** tick positions    num_ticks = 2  # Adjust as needed    tick_values = np.linspace(vmin, vmax, num_ticks)  # Ensures equal spacing        # Apply ticks and labels    cbar.set_ticks(tick_values)    cbar.set_ticklabels([f'{b:.1f}' for b in tick_values])    # Define the boundaries for each color block    cbar.ax.tick_params(labelsize=18)             # Set the colorbar label    cbar.set_label('∆B$_{Irr}$ \nm yr$^{-1}$', fontsize=18, ha='left', rotation=0, labelpad=0, linespacing=0.8)    cbar.ax.yaxis.label.set_position((1.1, 1.4))  # (X, Y) - Adjust Y to move up    cbar.ax.yaxis.set_label_position('left')        gdf["marker_size"]=(np.sqrt(gdf['rgi_area_km2'])*5)**1.3    scatter = ax.scatter(gdf.geometry.x, gdf.geometry.y,                         s=gdf['marker_size'], c=gdf['B_delta_irr'], cmap=custom_cmap, norm=norm, edgecolor='k', alpha=0.8)        #plot subregion lines                for attribute, subregion in subregions.groupby('o2region'):           # Uncomment for coloring of specific subregions            linecolor = "black"  # if subregion.o2region.values in highlighted_subregions else "black"        # subregion.plot(ax=ax, edgecolor='yellow', linewidth=4,        subregion.plot(ax=ax, edgecolor='black', linewidth=1.2,                      facecolor='none') # facecolor=region_colors[i],, alpha=0.4 # Plot the subregion        # i+=1            """ Add volume legend"""    custom_sizes = [200, 2000]#500, 1000, 2000, 3000]  # Example sizes for the legend (area)    size_labels = [f"{size:.0f}" for size in custom_sizes]  # Create labels for sizes        # Create legend handles (scatter points with different sizes)    legend_handles = [        plt.scatter([], [], s=(np.sqrt(size)*5)**1.3, edgecolor='k', facecolor='none')        for size in custom_sizes    ]  # Adjust size factor if needed    text_handles = [Line2D([0], [0], linestyle="none", label=label) for label in size_labels]                # Create a separate axis for the legend    if var=="T":        cax_legend = fig.add_axes([-0.015, 0.12, 0.15, 0.2])  # [left, bottom, width, height]        # cax_legend = fig.add_axes([-0.015, 0.12, 0.15, 0.2])  # [left, bottom, width, height]        # cax_legend = fig.add_axes([w_leg -0.015, h_leg+0.1, 0.15, 0.1])  # [left, bottom, width, height]                        # Remove axis visuals        cax_legend.set_frame_on(False)  # Hide frame        cax_legend.set_xticks([])  # Remove x-ticks        cax_legend.set_yticks([])  # Remove y-ticks                # Add legend to the separate axis        legend = cax_legend.legend(            legend_handles, size_labels, loc="center",            fontsize=18, ncol=1,frameon=False, title="Total Area \n km$^2$", title_fontsize=18, scatterpoints=1, labelspacing=1)            # Remove tick marks but keep the tick labels    if var=="P":        ax.text(0.97, 0.98, f"b",transform=ax.transAxes,ha='right', va='top',fontsize=20, fontweight='bold')        ax.text(0.21, 0.98,fr'$\Delta$P$_{{\text{{Irr-NoIrr}}}}$ only',transform=ax.transAxes,ha='right', va='top',fontsize=20, fontweight='bold')    else:        ax.text(0.97, 0.98, f"a",transform=ax.transAxes,ha='right', va='top',fontsize=20, fontweight='bold')        ax.text(0.21, 0.98,fr'$\Delta$T$_{{\text{{Irr-NoIrr}}}}$ only',transform=ax.transAxes,ha='right', va='top',fontsize=20, fontweight='bold')                fig.tight_layout()    # fig_folder = os.path.join(fig_path, "04. Map")    # os.makedirs(fig_folder, exist_ok=True)    # fig_path = '/Users/magaliponds/Library/CloudStorage/OneDrive-VrijeUniversiteitBrussel/1. VUB/02. Research/01. IRRMIP/04. Figures/99. Final Figures/'        # plt.savefig(f"{fig_path}/00. Appendix/Map_Plot_sA_c{scatter_data}_boxV_IRR_1985_2014_P_only.png", dpi=300, bbox_inches="tight", pad_inches=0.1)        # plt.show()      return axfig,axes = plt.subplots(1,2,figsize=(20,8), subplot_kw={                       'projection': ccrs.PlateCarree()}, )axes=axes.flatten()map_plot_onevar_only("T",fig, axes[0])map_plot_onevar_only("P",fig, axes[1])  plt.show()    #%% Cell 8: Analyse Robustness of CESM2 data global_full = xr.open_dataset(f"{wd_path}masters/master_volume_ts_global_members.nc")global_full_med = xr.open_dataset(f"{wd_path}masters/master_volume_ts_global_members_median.nc")# ds_subregions = xr.open_dataset(f"{wd_path}masters/master_volume_ts_subregions_members.nc")# ds_subregions_med = xr.open_dataset(f"{wd_path}masters/master_volume_ts_subregions_members_median.nc")members_averages = [2, 3,   5, 1,3] models_shortlist = ["E3SM", "CESM2", "CNRM", "IPSL-CM6","NorESM"]plt.rcParams.update({'font.size': 10})  # applies to all text elementsfig,axes = plt.subplots(1,2, figsize=(10,4))fig.subplots_adjust(wspace=0.3, hspace=0.4)ax=axes.flatten()#plot the median volume evolution over all HMA# median = global_full_med.sel(member='14-member-med')# std = global_full_med.drop_sel(member="14-member-med").volume.std(dim="member")/1000median = global_full.sel(member='14-member-avg')std = global_full.drop_sel(member="14-member-avg").volume.std(dim="member")/1000ax[0].plot(median.time, median.volume/1000, color='k', ls='-', lw=2, alpha=1, label = 'median')ax[0].fill_between(median.time, median.volume/1000-std, median.volume/1000+std, color='#648FFF', alpha=0.25, label='±1std')# ax[0].set_title('Volume evolution per member')ax[0].set_ylabel("Volume [km$^3$]")ax[0].text(0.03,0.93,"a.", fontweight='bold', transform=ax[0].transAxes,)ax[0].set_yticks([v * 1e9 for v in [5.8, 6, 6.2, 6.4]])ax[0].set_xticks([1985, 2000, 2015])# ax[0].set_xticklabels(['Zero', 'Two', 'Four', 'Six', 'Eight'])# Delta method - (model-median)/spread for each of the model members over time# delta = (global_full_med - median)/std# delta_median = delta.sel(member='14-member-med')# ax[1].scatter(delta_median.time, delta_median.volume, color='k', ls='-',alpha=0.8, label = 'median')# ax[1].set_title(f" ∆ = (member - median)/std")# Root mean square distancermsd_all = np.sqrt(((global_full_med.volume - median) ** 2).mean(dim="time"))nrmsd_all = rmsd_all / median.mean(dim="time")   # relative RMSDax[1].set_ylim((0,0.018))# ax[1].set_title(fr"$\mathrm{{nRMSD}}$")ax[1].text(0.03,0.83 ,fr"$\mathrm{{nRMSD}} = \frac{{\sqrt{{\frac{{1}}{{N}}\sum_i (x_i - y_i)^2}}}}{{\sigma}}$", transform=ax[1].transAxes)  # use axes coordinates)ax[1].set_ylabel("nRMSD [-]")ax[1].text(0.03,0.93,"b.", fontweight='bold', transform=ax[1].transAxes,)ax[1].text(0.99,0.025,"Closest to median", fontweight='medium', transform=ax[1].transAxes, ha='right')ax[1].text(0.99,0.925,"Furthest from median", fontweight='medium', transform=ax[1].transAxes, ha='right')ax[1].set_yticks([0,0.005,0.01,0.015])#plot per member volume evolution, delta for m, model in enumerate(models_shortlist):    for j in range(members_averages[m]):        i = 0 if model=='IPSL-CM6' else 1        color ='#5583F9' if model =='CESM2' else 'darkgrey'        sample_id = f'{model}.00{j+i}'        sample=global_full_med.sel(member=sample_id)        # delta_sample = delta.sel(member=sample_id)        nrmsd_all_sample = nrmsd_all.sel(member=sample_id)                ax[0].plot(sample.time, sample.volume/1000, color=color, ls='--', lw=1.5)        # ax[1].scatter(delta_sample.time, delta_sample.volume, color=color)        ax[1].scatter(nrmsd_all_sample.member, nrmsd_all_sample.volume, color=color)        ax[1].tick_params(axis="x", rotation=45)        for label in ax[1].get_xticklabels():            label.set_ha('right') # handles = ax[0].handles# Define custom legend elementslegend_elements = [    Line2D([0], [0], color="black", lw=2, label="Ensamble mean"),    # Line2D([0], [0], color="black", lw=2, label="Ensamble median"),    Line2D([0], [0], color="#5583F9", lw=2, ls ='--', label="CESM2 members"),    Line2D([0], [0], color="grey", lw=2, ls='--', label="Other members"),     mpatches.Patch(facecolor="#648FFF", edgecolor="none", alpha=0.25, label="±1 std (All members)"),]# Add to plotax[0].legend(handles=legend_elements, loc="best", frameon=False)plt.tight_layout()fig_path = '/Users/magaliponds/Library/CloudStorage/OneDrive-VrijeUniversiteitBrussel/1. VUB/02. Research/01. IRRMIP/04. Figures/98. Final Figures A+1km2/01. Extended_Data'plt.savefig(f'{fig_path}/Robustness_analysis', dpi=300)#%% Cell 8b: Rank based assessment for CESM2 datadist = abs(global_full_med.volume.mean(dim='time') - median.mean(dim='time'))rank = dist.rank(dim="member").to_dataframe().sort_values(by=['volume'])dist_ts = abs(global_full_med.volume - median)rank_ts = dist_ts.rank(dim="member").to_dataframe()[['volume']].sort_values(by=['volume'])df_pivot = rank_ts.reset_index().pivot(index="member", columns="time", values="volume")fig_path = '/Users/magaliponds/Library/CloudStorage/OneDrive-VrijeUniversiteitBrussel/1. VUB/02. Research/01. IRRMIP/04. Figures/98. Final Figures A+1km2/01. Extended_Data'# os.makedirs(f"{fig_path}/", exist_ok=True)df_pivot.to_csv(f"{fig_path}/rank_based_assesment.csv")#%% Cell 9: Analyse run with hydro outputopath_df_monthly = os.path.join(wd_path,'masters','hydro_output_monthly_subregions.csv')opath_df_annual = os.path.join(wd_path,'masters','hydro_output_annual_subregions.csv')ds=pd.read_csv(opath_df_monthly)