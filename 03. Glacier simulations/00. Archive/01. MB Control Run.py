# -*- coding: utf-8 -*-import oggmimport oggmfrom oggm import utils, cfg, workflow, tasks, DEFAULT_BASE_URL, graphics, global_tasksfrom oggm.core import massbalance, flowlinefrom oggm.utils import floatyear_to_date, hydrodate_to_calendardatefrom oggm.sandbox import distribute_2dfrom oggm.sandbox.edu import run_constant_climate_with_biasimport geopandas as gpdimport matplotlib.pyplot as pltimport matplotlib.cm as cmimport xarray as xrimport osimport seaborn as snsimport salemfrom matplotlib.ticker import FuncFormatterimport pandas as pdimport numpy as npfrom matplotlib import animationfrom IPython.display import HTML, displaycmap=cm.get_cmap('bone')colors=[cmap(i / 5) for i in range(6)]folder_path='/Users/magaliponds/Library/CloudStorage/OneDrive-VrijeUniversiteitBrussel/1. VUB/02. Coding/01. IRRMIP/02. Data/06. OGGM Working Directories'wd_path=f'{folder_path}/01. MB Control Run'Hugonnet_path = '/Users/magaliponds/Library/CloudStorage/OneDrive-VrijeUniversiteitBrussel/1. VUB/02. Coding/01. IRRMIP/02. Data/05. Reference/Hugonnet_time_series_13/dh_13_14_15_rgi60_pergla_cumul.csv'sns.set_context('notebook') #plot defaults#OGGM optionsoggm.cfg.initialize(logging_level='WARNING')oggm.cfg.PATHS['working_dir']=utils.mkdir(wd_path, reset=False)oggm.cfg.PARAMS['store_model_geometry']=Truecfg.PARAMS['use_multiprocessing'] = False#define the glaciers we will play with# rgi_ids=['RGI60-13.37574', 'RGI60-13.37682', 'RGI60-13.37753',  'RGI60-13.53223', 'RGI60-13.53720']rgi_ids=['RGI60-13.01337', 'RGI60-13.37824', 'RGI60-13.00967',  'RGI60-13.38774', 'RGI60-13.40982']#preparing the glacier database_url = 'https://cluster.klima.uni-bremen.de/~oggm/gdirs/oggm_v1.6/L3-L5_files/2023.3/elev_bands/W5E5'gdirs = workflow.init_glacier_directories(    rgi_ids, #using RGI IDS specified before    prepro_base_url=DEFAULT_BASE_URL, #using base_url with W5E5 data    from_prepro_level=5, #using pre-pro level 5, indicating the model has been calibrated, and uses a pre-computed model run from the RGI outline date to the last possible date given by historical climate data    prepro_border=80 #ndicates the number of grid points which we’d like to add to each side of the glacier for the local map    )# print('Path to the DEM:', gdir.get_filepath('dem'))rgi_dates = [gdir.rgi_date for gdir in gdirs]# print(rgi_dates) #find rgi_dates for all glaciers: 2010 for all 5# ---- """ Historical climate data check """# Load and open Historical run from the new default climate dataset GSWP3_W5E5, this is until the end of 2019, so the volume is computed until January 1st, 2020. # fig_climdata, axes_climdata = plt.subplots(5,2,figsize=(14, 8))# for (i,gdir) in enumerate(gdirs):#     print(i)#     # gdir.get_file_path('climate_historical')  #Get filepath to climate historical data#     with xr.open_dataset(gdir.get_filepath('climate_historical')) as ds:#         ds = ds.load()#         # print(ds)#         # ds_timesample = ds.sel(time=slice('1985-01-01', '2014-12-31')) #select only relevant years#         yearly_average_t = ds.sel(time=slice('1985-01-01', '2014-12-31')).resample(time='YE').mean(dim='time')#         yearly_total_p= ds.sel(time=slice('1985-01-01', '2014-12-31'))#         print(yearly_total_p.sel(time=str(1985)).prcp)#         yearly_total_p=yearly_total_p.resample(time='Y').sum()#         print(yearly_total_p.prcp)                #         # print(ds)#         axes_climdata[i,0].bar(yearly_total_p.time.dt.year, yearly_total_p['prcp'], label=gdir.name, color=colors[i])  # Plot precipitation on the first subplot#         axes_climdata[i,1].plot(yearly_average_t.time, yearly_average_t['temp'], label=gdir.name, color=colors[i])  # Plot temperature on the second subplot# # Set titles and labels for the subplots#         axes_climdata[i,0].set_title(gdir.name)#         axes_climdata[i,1].set_title(gdir.name)        #         multiannual_mean_P = yearly_total_p['prcp'].mean(dim='time')#         multiannual_mean_T = yearly_average_t['temp'].mean(dim='time')        #         axes_climdata[i, 0].annotate(f'Multi-annual mean: {multiannual_mean_P:.2f} mm',#                                       xy=(0.02, 0.95), xycoords='axes fraction',#                                       ha='left', va='top', fontsize=10, color='black',#                                       bbox=dict(facecolor='none', edgecolor='none', boxstyle='round,pad=0.5'))#         axes_climdata[i, 1].annotate(f'Multi-annual mean: {multiannual_mean_T:.2f} °C',#                                       xy=(0.02, 0.95), xycoords='axes fraction',#                                       ha='left', va='top', fontsize=10, color='black',#                                       bbox=dict(facecolor='none', edgecolor='none', boxstyle='round,pad=0.5'))        #         for j in [0,1]:#             if i == len(gdirs) - 1:#                 axes_climdata[i, j].set_xlabel('Year')#             else:#                 axes_climdata[i, j].xaxis.set_visible(False)                    # axes_climdata[4,0].set_xlabel('Time')# axes_climdata[2,0].set_ylabel('Total annual precipitation [mm]')# axes_climdata[4,1].set_xlabel('Time')# axes_climdata[2,1].set_ylabel('Mean annual temperature [°C]')# plt.subplots_adjust(left=0.1, bottom=0.1, right=0.9, top=0.9, wspace=0.25, hspace=0.6)# plt.show()# df=ds.to_dataframe()# print(df[df.index.year==1985].sum())   # --------       ''' Derive run output from historical spinup and plot area and volume data '''ds = utils.compile_run_output(gdirs, input_filesuffix='_spinup_historical')ds_time = ds.sel(time=slice('1985-01-01', '2015-12-31'))fig_vol, axes_vol = plt.subplots(5,1,figsize=(9, 8))axes_area = [ax.twinx() for ax in axes_vol]for (i,gdir) in enumerate(gdirs):    print(gdir.rgi_id)    ds_timesample=ds_time.sel(rgi_id=gdir.rgi_id)       axes_vol[i].plot(ds_timesample.time, ds_timesample.volume, label=ds_timesample.rgi_id, color=colors[i])    axes_area[i].scatter(ds_timesample.time, ds_timesample.area, color=colors[i])    axes_vol[i].set_title(gdir.rgi_id)    axes_vol[i].yaxis.set_major_formatter(plt.FormatStrFormatter('%.2e'))    axes_area[i].yaxis.set_major_formatter(plt.FormatStrFormatter('%.2e'))        if i == len(gdirs) - 1:        axes_vol[i].set_xlabel('Year')    else:        axes_vol[i].xaxis.set_visible(False)              print(ds_timesample)plt.subplots_adjust(left=0.1, bottom=0.1, right=0.9, top=0.9, wspace=0.3, hspace=0.6)axes_vol[2].set_ylabel('Volume [m$^3$]')axes_area[2].set_ylabel('Area [m$^2$]')''' Derive mass balance model and compute specific mass balance for this model '''#only mb plot# for (i,gdir) in enumerate(gdirs):#     #calibrated mass balance model - default is to use the OGGM's MonthlyTIModel#     mbmod = massbalance.MultipleFlowlineMassBalance(gdir) #     fls = gdir.read_pickle('model_flowlines') #     years = np.arange(1985, 2015) #     mb_ts = mbmod.get_specific_mb(fls=fls, year=years)#     plt.plot(years, mb_ts, color=colors[i], label=gdir.rgi_id)#     plt.ylabel('Specific MB (mm w.e.)');# # hugo_df = pd.read_csv(Hugonnet_path)# # hugo_filtered = hugo_df[hugo_df['rgiid'].isin(rgi_ids)]# # hugo_ds = xr.Dataset.from_dataframe(hugo_df)# # output_file = '/Users/magaliponds/Library/CloudStorage/OneDrive-VrijeUniversiteitBrussel/1. VUB/02. Coding/01. IRRMIP/02. Data/05. Reference/Hugonnet_time_series_13/hugo_ds.nc'# # hugo_ds.to_netcdf(output_file)# # hugo_ds = xr.open_dataset(output_file)# # print(hugo_ds.head)# # variables_to_keep=['rgiid', 'time', 'area', 'dh']# # hugo_ds = hugo_ds[variables_to_keep]# output_file_2 = '/Users/magaliponds/Library/CloudStorage/OneDrive-VrijeUniversiteitBrussel/1. VUB/02. Coding/01. IRRMIP/02. Data/05. Reference/Hugonnet_time_series_13/hugo_ds_reduced.nc'# # hugo_ds.to_netcdf(output_file_2)# hugo_ds = xr.open_dataset(output_file_2)# for (i,gdir) in enumerate(gdirs):#     filtered_ds = hugo_ds.where(hugo_ds['rgiid'] == gdir.rgi_id, drop=True)#     filtered_ds = filtered_ds.set_coords('time')#     filtered_ds['time'] = pd.to_datetime(filtered_ds['time'].values) #     filtered_ds = filtered_ds.resample(time='YE').mean(dim='time')#     if i==0:#        f plt.plot(filtered_ds.time,  filtered_ds.dh[:,1], color=colors[i], label='Hugonnet', linestyle='-')#     else:#         plt.plot(filtered_ds.time,  filtered_ds.dh[:,1], color=colors[i], label=None, linestyle='-')   #     plt.legend(ncol=3, loc='lower center', bbox_to_anchor=(0.5,-0.3))    # # for (i,gdir) in enumerate(gdirs):#     #calibrated mass balance model - default is to use the OGGM's MonthlyTIModel#     # mbmod = massbalance.MultipleFlowlineMassBalance(gdir) #     # fls = gdir.read_pickle('model_flowlines') #     # years = np.arange(1985, 2015) #     # mb_ts = mbmod.get_specific_mb(fls=fls, year=years)#     plt.plot(hugo_df.time, hugo_df.dh, color=colors[i], label=hugo_ds.rgiid)#     plt.ylabel('dh (mm)');# plt.legend(ncol=3, loc='lower center', bbox_to_anchor=(0.5,-0.3))# # Filter based on rgi_ids using boolean indexing