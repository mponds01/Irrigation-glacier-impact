# -*- coding: utf-8 -*-import oggm""" This script compares consists of the following cells1a. Load the RGI and Hugonnet data for the selected test glaciers1b. Load WGMS data 2. Check and plot the historical climate data for the test glaciers3. Plot Area and Volume from historical spinup output4. Load specific mass balacne model from OGGM5. Filter Hugonnet data (only keeping relevant variables)6. Create a plot with Hugonnet & OGGM modelled MB (10 year average)6a. Create a plot with Hugonnet & OGGM modelled MB (20 year average)7. Plot extended Hugonnet data (cumulative monthly data file) - outdated8. Plot extended Hugonnet data (non cumulative monthly data file) - outdated9. Plot with Hugonnet data and oGGM averages - outdated"""import oggmfrom oggm import utils, cfg, workflow, tasks, DEFAULT_BASE_URL, graphics, global_tasksfrom oggm.core import massbalance, flowlinefrom oggm.utils import floatyear_to_date, hydrodate_to_calendardatefrom oggm.sandbox import distribute_2dfrom oggm.sandbox.edu import run_constant_climate_with_biasimport geopandas as gpdimport matplotlib.pyplot as pltimport matplotlib.cm as cmimport xarray as xrimport osimport seaborn as snsimport salemfrom matplotlib.ticker import FuncFormatterimport pandas as pdimport numpy as npfrom matplotlib import animationfrom IPython.display import HTML, displaycmap=cm.get_cmap('bone')colors=[cmap(i / 9) for i in range(10)]#%% Cell 1: Load data & Hugonnet model""" Load the data """folder_path='/Users/magaliponds/Library/CloudStorage/OneDrive-VrijeUniversiteitBrussel/1. VUB/02. Coding/01. IRRMIP/02. Data/06. OGGM Working Directories'wd_path=f'{folder_path}/01. MB Control Run'Hugonnet_path = '/Users/magaliponds/Library/CloudStorage/OneDrive-VrijeUniversiteitBrussel/1. VUB/02. Coding/01. IRRMIP/02. Data/05. Reference/Hugonnet_time_series_13/dh_13_rgi60_pergla_rates.csv'sns.set_context('notebook') #plot defaults#OGGM optionsoggm.cfg.initialize(logging_level='WARNING')oggm.cfg.PATHS['working_dir']=utils.mkdir(wd_path, reset=False)oggm.cfg.PARAMS['store_model_geometry']=Truecfg.PARAMS['use_multiprocessing'] = False#define the glaciers we will play with# rgi_ids=['RGI60-13.37574', 'RGI60-13.37682', 'RGI60-13.37753',  'RGI60-13.53223', 'RGI60-13.53720'] #initial rgi_ids, based on Farinotti map# rgi_ids=['RGI60-13.01337', 'RGI60-13.37824', 'RGI60-13.00967',  'RGI60-13.38774', 'RGI60-13.40982'] #original rgi_ids based on selected procedurergi_ids = ["RGI60-13.40102", # Area >10km2  "RGI60-13.39195", # Area >10km2  "RGI60-13.36881", # Area >10km2  "RGI60-13.38969", # Area >10km2  "RGI60-13.37184", # Area >10km2  "RGI60-13.00967", # Area <10km2  "RGI60-13.40982", # Area <10km2  "RGI60-13.41891", # WGMS observation  "RGI60-13.23659", # WGMS observation] base_url = 'https://cluster.klima.uni-bremen.de/~oggm/gdirs/oggm_v1.6/L3-L5_files/2023.3/elev_bands/W5E5'gdirs = workflow.init_glacier_directories(    rgi_ids, #using RGI IDS specified before    prepro_base_url=DEFAULT_BASE_URL, #using base_url with W5E5 data    from_prepro_level=5, #using pre-pro level 5, indicating the model has been calibrated, and uses a pre-computed model run from the RGI outline date to the last possible date given by historical climate data    prepro_border=80 #ndicates the number of grid points which weâ€™d like to add to each side of the glacier for the local map    )print(gdirs)# print('Path to the DEM:', gdir.get_filepath('dem'))rgi_dates = [gdir.rgi_date for gdir in gdirs]# print(rgi_dates) #find rgi_dates for all glaciers: 2010 for all 5#%%% Cell 1b: Load WGMS observational dataWGMS_info_path ="/Users/magaliponds/Library/CloudStorage/OneDrive-VrijeUniversiteitBrussel/1. VUB/02. Coding/01. IRRMIP/02. Data/05. Reference/WGMS-MB/data/glacier.csv"WGMS_B_path="/Users/magaliponds/Library/CloudStorage/OneDrive-VrijeUniversiteitBrussel/1. VUB/02. Coding/01. IRRMIP/02. Data/05. Reference/WGMS-MB/data/mass_balance.csv"WGMS_B = pd.read_csv(WGMS_B_path)WGMS_B = xr.Dataset.from_dataframe(WGMS_B)WGMS_I = pd.read_csv(WGMS_info_path)WGMS_I = xr.Dataset.from_dataframe(WGMS_I)condition = (WGMS_I.GLACIER_REGION_CODE == 'ASC') & ((WGMS_I.GLACIER_SUBREGION_CODE == 'ASC-02') | (WGMS_I.GLACIER_SUBREGION_CODE == 'ASC-09'))WGMS_I_13 = WGMS_I.where(condition, drop=True)WGMS_I_13['WGMS_ID'] = WGMS_I_13['WGMS_ID'].astype(int)# print(WGMS_I_13)objs=[WGMS_I_13,WGMS_B]#merge data based on selected WGMS-I IDs, all data that do not match dont result in the dataset (hence len WGMS_I should be equal to length of merged dataset)WGMS = xr.merge(objs, compat="override", join="inner")condition2 = WGMS['ANNUAL_BALANCE'].notnull()WGMS = WGMS.where(condition, drop=True)#%% Cell 2: Historical climate data check""" Historical climate data check """# Load and open Historical run from the new default climate dataset GSWP3_W5E5, this is until the end of 2019, so the volume is computed until January 1st, 2020. fig_climdata, axes_climdata = plt.subplots(9,2,figsize=(14, 10), sharey='col')  # Adjust the second row to be taller)for (i,gdir) in enumerate(gdirs):    print(i)    utils.compile_glacier_statistics(gdirs)    # gdir.get_file_path('climate_historical')  #Get filepath to climate historical data    with xr.open_dataset(gdir.get_filepath('climate_historical')) as ds:        ds = ds.load()        # print(ds)        # ds_timesample = ds.sel(time=slice('1985-01-01', '2014-12-31')) #select only relevant years        yearly_average_t = ds.sel(time=slice('1985-01-01', '2014-12-31')).resample(time='YE').mean(dim='time')        yearly_total_p= ds.sel(time=slice('1985-01-01', '2014-12-31'))        # print(yearly_total_p.sel(time=str(1985)).prcp)        yearly_total_p=yearly_total_p.resample(time='Y').sum()        # print(yearly_total_p.prcp)                        # print(ds)        bars1= axes_climdata[i,0].bar(yearly_total_p.time.dt.year, yearly_total_p['prcp'], label=gdir.name, color=colors[i])  # Plot precipitation on the first subplot        bars2=axes_climdata[i,1].plot(yearly_average_t.time, yearly_average_t['temp'], label=gdir.name, color=colors[i])  # Plot temperature on the second subplot        #  Set titles and labels for the subplots        print(gdir.name)        axes_climdata[i,0].set_title(gdir.rgi_id)        axes_climdata[i,1].set_title(gdir.rgi_id)                multiannual_mean_P = yearly_total_p['prcp'].mean(dim='time')        multiannual_mean_T = yearly_average_t['temp'].mean(dim='time')                axes_climdata[i, 0].annotate(f'30yr avg: {multiannual_mean_P:.2f} mm',                                       xy=(0.7, 0.95), xycoords='axes fraction',                                       ha='left', va='top', fontsize=10, color='black',                                       bbox=dict(facecolor='none', edgecolor='none', boxstyle='round',pad=1))        axes_climdata[i, 1].annotate(f'30yr avg: {multiannual_mean_T:.2f} Â°C',                                       xy=(0.7, 0.95), xycoords='axes fraction',                                       ha='left', va='top', fontsize=10, color='black',                                       bbox=dict(facecolor='none', edgecolor='none', boxstyle='round',pad=1))                        for j in [0,1]:            if i == len(gdirs) - 1:                axes_climdata[i, j].set_xlabel('Year')            else:                axes_climdata[i, j].xaxis.set_visible(False)                    # axes_climdata[5,0].set_xlabel('Time')# axes_climdata[3,0].set_ylabel('Total annual precipitation [mm]')# axes_climdata[4,1].set_xlabel('Time')# axes_climdata[2,1].set_ylabel('Mean annual temperature [Â°C]')plt.subplots_adjust(left=0.1, bottom=0.1, right=0.9, top=0.9, wspace=0.15, hspace=0.6)plt.show()df=ds.to_dataframe()print(df[df.index.year==1985].sum())#%% Cell 3: Historical Spinup output''' Derive run output from historical spinup and plot area and volume data '''ds = utils.compile_run_output(gdirs, input_filesuffix='_spinup_historical')ds_time = ds.sel(time=slice('1985-01-01', '2015-12-31'))fig_vol, axes_vol = plt.subplots(9,1,figsize=(9, 10))axes_area = [ax.twinx() for ax in axes_vol]for (i,gdir) in enumerate(gdirs):    print(gdir.rgi_id)    ds_timesample=ds_time.sel(rgi_id=gdir.rgi_id)    axes_vol[i].plot(ds_timesample.time, ds_timesample.volume, label=gdir.rgi_id, color=colors[i])    axes_area[i].scatter(ds_timesample.time, ds_timesample.area, color=colors[i])    axes_vol[i].set_title(gdir.rgi_id)    axes_vol[i].yaxis.set_major_formatter(plt.FormatStrFormatter('%.2e'))    axes_area[i].yaxis.set_major_formatter(plt.FormatStrFormatter('%.2e'))        if i == len(gdirs) - 1:        axes_vol[i].set_xlabel('Year')    else:        axes_vol[i].xaxis.set_visible(False)              if i ==len(gdirs)-1:         axes_vol[i].plot(0, 0, label='Volume', color='grey')        axes_area[i].scatter(0,0, color='grey', label='Area')    axes_vol[i].set_xlim(min(ds_timesample.time), max(ds_timesample.time))    print(ds_timesample)plt.subplots_adjust(left=0.1, bottom=0.1, right=0.9, top=0.9, wspace=0.3, hspace=0.6)axes_vol[4].set_ylabel('Volume [m$^3$]')axes_area[4].set_ylabel('Area [m$^2$]')fig_vol.legend(loc='upper right', ncols=1, bbox_to_anchor=(1.3,0.63))#%% Cell 4: MB model and specific MB calculation''' Derive mass balance model and compute specific mass balance for this model '''#only mb plotfor (i,gdir) in enumerate(gdirs):    #calibrated mass balance model - default is to use the OGGM's MonthlyTIModel    mbmod = massbalance.MultipleFlowlineMassBalance(gdir)     fls = gdir.read_pickle('model_flowlines')     years = np.arange(1985, 2020)     mb_ts = mbmod.get_specific_mb(fls=fls, year=years)    plt.plot(years, mb_ts, color=colors[i], label=gdir.rgi_id)    plt.ylabel('Specific MB (mm w.e.)');    plt.legend(ncols=3, loc='lower center', bbox_to_anchor=(0.5,-0.4))#%% Cell 5: Load original hugonnet data""" Load Hugonnet data and keep only relevant variables and rgis"""hugo_df = pd.read_csv(Hugonnet_path)# # hugo_filtered = hugo_df[hugo_df['rgiid'].isin(rgi_ids)]hugo_ds_og = xr.Dataset.from_dataframe(hugo_df)hugo_ds_og = hugo_ds_og.set_index(index='period')#Keep only relevant variables and rgi_ids in hugonnet dataset and store for later use # output_file = '/Users/magaliponds/Library/CloudStorage/OneDrive-VrijeUniversiteitBrussel/1. VUB/02. Coding/01. IRRMIP/02. Data/05. Reference/Hugonnet_time_series_13/hugo_ds.nc'# hugo_ds.to_netcdf(output_file)# hugo_ds = xr.open_dataset(output_file)# print(hugo_ds.head)# variables_to_keep=['rgiid', 'time', 'area', 'dh']# hugo_ds = hugo_ds[variables_to_keep]#save edited dataset for later useoutput_file_2 = '/Users/magaliponds/Library/CloudStorage/OneDrive-VrijeUniversiteitBrussel/1. VUB/02. Coding/01. IRRMIP/02. Data/05. Reference/Hugonnet_time_series_13/hugo_ds_reduced.nc'# hugo_ds.to_netcdf(output_file_2)#load hugonnet data if its already modifed and saved for later runs hugo_ds = xr.open_dataset(output_file_2)hugo_ds = hugo_ds.set_index(index='time')#%% Cell 6: Load Hugonnet OGGM plotmbdf = utils.get_geodetic_mb_dataframe()years = np.arange(1985, 2020) mb = pd.DataFrame({'years': years})mb['years'] = pd.to_datetime(mb['years'], format='%Y')fig_mb, axes_mb = plt.subplots(3,3, figsize=(20, 12), sharex=True)axes_mb = axes_mb.flatten()  # Flatten the 2D array of axes to simplify indexingfor (i, gdir) in enumerate(gdirs):            mbmod = massbalance.MultipleFlowlineMassBalance(gdir)     fls = gdir.read_pickle('model_flowlines')     B = mbmod.get_specific_mb(fls=fls, year=years)    mb['B'] = B        mb_2010 = mb[(mb['years'] >= '2000-01-01') & (mb['years'] < '2010-01-01')]    mean_mb_2010 = mb_2010['B'].mean()    mb_2020 = mb[(mb['years'] >= '2010-01-01') & (mb['years'] < '2020-01-01')]    mean_mb_2020 = mb_2020['B'].mean()        sel = mbdf.loc[gdir.rgi_id].set_index('period') * 1000       # Load & plot Hugonnet data for 2000-2010    _mb, _err = sel.loc['2000-01-01_2010-01-01'][['dmdtda', 'err_dmdtda']]    axes_mb[i].fill_between([2000, 2010], [_mb-_err, _mb-_err], [_mb+_err, _mb+_err], alpha=0.5, color='C0')    axes_mb[i].plot([2000, 2010], [_mb, _mb], color='C0', label='Hugonnet 2000-2010')        # Load & plot Hugonnet data for 2010-2020    _mb, _err = sel.loc['2010-01-01_2020-01-01'][['dmdtda', 'err_dmdtda']]    axes_mb[i].fill_between([2010, 2020], [_mb-_err, _mb-_err], [_mb+_err, _mb+_err], alpha=0.5, color='C1')    axes_mb[i].plot([2010, 2020], [_mb, _mb], color='C1', label='Hugonnet 2010-2020')        # Plot (mean) modelled data     axes_mb[i].plot([2000, 2010], [mean_mb_2010, mean_mb_2010], color='C0', linestyle='dashed', label='OGGM modelled mean 2000-2010')    axes_mb[i].plot([2010, 2020], [mean_mb_2020, mean_mb_2020], color='C1', linestyle='dashed', label='OGGM modelled mean 2010-2020')    axes_mb[i].plot(years, mb.B, c='k', label='OGGM Modelled')        # Format graphs    axes_mb[i].set_title(gdir.rgi_id)    # axes_mb[i].plot(years, mb.B, c='k', label='OGGM Modelled')        if i % 2 == 0:  # Only set ylabel on the left column        axes_mb[i].set_ylabel('B [mm w.e.]')plt.subplots_adjust(left=0.1, bottom=0.1, right=0.9, top=0.9, wspace=0.2, hspace=0.2)plt.legend(loc='lower center', bbox_to_anchor=(-0.75, -0.5), ncols=3)plt.show()#%% Cell 6a: Load Hugonnet OGGM dataframe - 2000-2020 average onlymbdf = utils.get_geodetic_mb_dataframe()years = np.arange(1985, 2020) mb = pd.DataFrame({'years': years})mb['years'] = pd.to_datetime(mb['years'], format='%Y')fig_mb, axes_mb = plt.subplots(3,3, figsize=(20, 12), sharex=True)axes_mb = axes_mb.flatten()  # Flatten the 2D array of axes to simplify indexingfor (i, gdir) in enumerate(gdirs):            mbmod = massbalance.MultipleFlowlineMassBalance(gdir)     fls = gdir.read_pickle('model_flowlines')     B = mbmod.get_specific_mb(fls=fls, year=years)    mb['B'] = B        # Load & plot Hugonnet data for 2000-2010    mb_2010_2020 = mb[(mb['years'] >= '2000-01-01') & (mb['years'] < '2020-01-01')]    mean_mb_2010_2020 = mb_2010_2020['B'].mean()    sel = mbdf.loc[gdir.rgi_id].set_index('period') * 1000       # Load & plot Hugonnet data for 2000-2010    _mb, _err = sel.loc['2000-01-01_2020-01-01'][['dmdtda', 'err_dmdtda']]    axes_mb[i].fill_between([2000, 2020], [_mb-_err, _mb-_err], [_mb+_err, _mb+_err], alpha=0.5, color='C0')    axes_mb[i].plot([2000, 2020], [_mb, _mb], color='C0', label='Hugonnet 2000-2010')        # Plot (mean) modelled data     axes_mb[i].plot([2000, 2020], [mean_mb_2010_2020, mean_mb_2010_2020], color='k', linestyle='dashed', label='OGGM modelled mean 2000-2020')    # axes_mb[i].plot([2010, 2020], [mean_mb_2020, mean_mb_2020], color='C1', linestyle='dashed', label='OGGM modelled mean 2010-2020')    axes_mb[i].plot(years, mb.B, c='k', label='OGGM Modelled')        # Format graphs    axes_mb[i].set_title(gdir.rgi_id)    # axes_mb[i].plot(years, mb.B, c='k', label='OGGM Modelled')        if i % 2 == 0:  # Only set ylabel on the left column        axes_mb[i].set_ylabel('B [mm w.e.]')plt.subplots_adjust(left=0.1, bottom=0.1, right=0.9, top=0.9, wspace=0.2, hspace=0.2)plt.legend(loc='lower center', bbox_to_anchor=(-0.75, -0.5), ncols=3)plt.show()#%% Cell 7: Plot extended Hugonnet data cumultative - outdated""" Plot extended, monthly hugonnet data """for (i,gdir) in enumerate(gdirs):       filtered_ds = hugo_ds.where(hugo_ds['rgiid'] == gdir.rgi_id, drop=True)    filtered_ds['index'] = pd.to_datetime(filtered_ds['index'])        #convert mm w.e. to m w.e.    filtered_ds['dh']=filtered_ds['dh']*100        # Group by year and calculate the mean    # filtered_ds = filtered_ds.groupby('year').mean()        plt.plot(filtered_ds.index,  filtered_ds.dh.values, color=colors[i], label=gdir.rgi_id)       plt.legend(ncol=3, loc='lower center', bbox_to_anchor=(0.5,-0.3))    plt.legend(ncol=3, loc='lower center', bbox_to_anchor=(0.5,-0.3))# Filter based on rgi_ids using boolean indexing#%% Cell 7b: Plot extended Hugonnet data non cumulative - outdated""" Plot extended, monthly hugonnet data """for (i,gdir) in enumerate(gdirs):       filtered_ds = hugo_ds.where(hugo_ds['rgiid'] == gdir.rgi_id, drop=True)        #convert mm w.e. to m w.e.    filtered_ds['dhdt']=filtered_ds['dhdt']*100    ds=filtered_ds        def parse_period(period_str):        start_str, end_str = period_str.split('_')        return pd.Timestamp(start_str), pd.Timestamp(end_str)    # Extract periods from dataset    periods = [parse_period(period_str) for period_str in ds['index'].values]        # Step 2: Filter based on period duration    # Assuming you want to select only 1-year periods    selected_periods = []    for period in periods:        start, end = period        if (end - start) == pd.Timedelta(days=365):  # Check if period is exactly 1 year            selected_periods.append(period)        # Step 3: Select data corresponding to the selected periods    selected_times = [f"{start.strftime('%Y-%m-%d')}_{end.strftime('%Y-%m-%d')}" for start, end in selected_periods]    ds_selected = ds.sel(index=selected_times)        # ds_selected now contains only the data for the 1-year periods        # Group by year and calculate the mean    # filtered_ds = filtered_ds.groupby('index.year').mean(dim='index')        # plt.plot(filtered_ds.index,  filtered_ds.dh.values, color=colors[i], label=gdir.rgi_id)    plt.plot(ds_selected.index,  ds_selected.dhdt.values, color=colors[i], label=gdir.rgi_id)    plt.xticks(rotation=90)    plt.ylabel('dhdt mm w.e. yr$^{-1}$')    # plt.legend(ncol=3, loc='lower center', bbox_to_anchor=(0.5,-0.3))    plt.legend(ncol=3, loc='lower center', bbox_to_anchor=(0.5,1))# Filter based on rgi_ids using boolean indexing#%% Cell 8: Plot Hugonnet data cumulative and compare to OGGM averages - outdated""" Plot extended, monthly hugonnet data icm OGGM data"""fig_mb, axes_mb = plt.subplots(5,1,figsize=(8,8), sharex=True)for (i,gdir) in enumerate(gdirs):        #load hugonnet data     filtered_ds = hugo_ds.where(hugo_ds['rgiid'] == gdir.rgi_id, drop=True)    filtered_ds['dh'] =filtered_ds['dh']*100    filtered_ds['index'] = pd.to_datetime(filtered_ds['index'])          #calculate mean of mb data    mb_2010 = filtered_ds.sel(index=slice('2000-01-01', '2009-12-31'))    mean_mb_2010 = mb_2010['dh'].mean()    mb_2020 = filtered_ds.sel(index=slice('2010-01-01', '2019-12-31'))    mean_mb_2020 = mb_2020['dh'].mean()        # Group by year and calculate the mean    filtered_ds = filtered_ds.groupby('index.year').mean(dim='index')    #select glacier indices for mb model in oggm    sel = mbdf.loc[gdir.rgi_id].set_index('period') * 1000       #Load & plot  Hugonnet data for 2000-2010    _mb, _err = sel.loc['2000-01-01_2010-01-01'][['dmdtda', 'err_dmdtda']]    axes_mb[i].fill_between([2000, 2010], [_mb-_err, _mb-_err], [_mb+_err, _mb+_err], alpha=0.5, color='C0');    axes_mb[i].plot([2000, 2010], [_mb, _mb], color='C0', label='Hugonnet 2000-2010');        #load & plot Hugonnet data for 2010-2020    _mb, _err = sel.loc['2010-01-01_2020-01-01'][['dmdtda', 'err_dmdtda']]    axes_mb[i].fill_between([2010, 2020], [_mb-_err, _mb-_err], [_mb+_err, _mb+_err], alpha=0.5, color='C1');    axes_mb[i].plot([2010, 2020], [_mb, _mb], color='C1', label='Hugonnet 2010-2020');        #Plot (mean) modelled data     axes_mb[i].plot([2000, 2010], [mean_mb_2010, mean_mb_2010], color='C0', linestyle='dashed', label='Modelled H. mean 2000-2010');    axes_mb[i].plot([2010, 2020], [mean_mb_2020, mean_mb_2020], color='C1', linestyle='dashed', label='Modelled H. mean 2010-2020');    # axes_mb[i].plot(years, mb.B, c='k', label='Modelled');        #format graphs    axes_mb[i].set_title(gdir.rgi_id)    # axes_mb[i].plot(years, mb.B, c='k', label='Modelled');    axes_mb[2].set_ylabel('B [mm w.e.]');       #convert mm w.e. to m w.e.    filtered_ds['dh']=filtered_ds['dh']        # Group by year and calculate the mean    # filtered_ds = filtered_ds.groupby('index.year').mean(dim='index')    axes_mb[i].plot(filtered_ds.year,filtered_ds.dh,label='Modelled Hugonnet yearly', color='k')   plt.subplots_adjust(left=0.1, bottom=0.1, right=0.9, top=0.9, wspace=0.3, hspace=0.6)   plt.legend(ncol=3, loc='lower center', bbox_to_anchor=(0.5,-1.2))#%% Cell 9: Create plot with Hugonnet data non cumulative and compare to OGGM averages - outdatedfor (i,gdir) in enumerate(gdirs):           #convert mm w.e. to m w.e.    ds=hugo_ds_og    selected_ds = ds.where(ds['rgiid'] == gdir.rgi_id, drop=True)        def parse_period(period_str):        start_str, end_str = period_str.split('_')        return pd.Timestamp(start_str), pd.Timestamp(end_str)    # Extract periods from dataset    periods = [parse_period(period_str) for period_str in selected_ds['index'].values]        # Step 2: Filter based on period duration    # Assuming you want to select only 1-year periods    selected_periods = []    print(selected_periods)    for period in periods:        start, end = period        if (end - start) == pd.Timedelta(days=365):  # Check if period is exactly 1 year            selected_periods.append(periods)        # Step 3: Select data corresponding to the selected periods    selected_times = [f"{start.strftime('%Y-%m-%d')}_{end.strftime('%Y-%m-%d')}" for start, end in selected_periods]    selected_ds = selected_ds.sel(index=selected_times)        # selected_ds['dhdt']=selected_ds['dhdt']        mb_2010 = selected_ds.sel(index=slice('2000-01-01_2001-01-01', '2009-01-01_2010-01-01'))    mean_mb_2010 = mb_2010['dhdt'].mean()    mb_2020 = selected_ds.sel(index=slice('2010-01-01_2011-01-01', '2019-01-01_2020-01-01'))    mean_mb_2020 = mb_2020['dhdt'].mean()        _mb, _err = sel.loc['2000-01-01_2010-01-01'][['dmdtda', 'err_dmdtda']]    axes_mb[i].fill_between([2000, 2010], [_mb-_err, _mb-_err], [_mb+_err, _mb+_err], alpha=0.5, color='C0');    axes_mb[i].plot([2000, 2010], [_mb, _mb], color='C0', label='Hugonnet 2000-2010');        #load & plot Hugonnet data for 2010-2020    _mb, _err = sel.loc['2010-01-01_2020-01-01'][['dmdtda', 'err_dmdtda']]    axes_mb[i].fill_between([2010, 2020], [_mb-_err, _mb-_err], [_mb+_err, _mb+_err], alpha=0.5, color='C1');    axes_mb[i].plot([2010, 2020], [_mb, _mb], color='C1', label='Hugonnet 2010-2020');        #Plot (mean) modelled data     axes_mb[i].plot([2000, 2010], [mean_mb_2010, mean_mb_2010], color='C0', linestyle='dashed', label='Modelled H. mean 2000-2010');    axes_mb[i].plot([2010, 2020], [mean_mb_2020, mean_mb_2020], color='C1', linestyle='dashed', label='Modelled H. mean 2010-2020');    # axes_mb[i].plot(years, mb.B, c='k', label='Modelled');        #format graphs    axes_mb[i].set_title(gdir.rgi_id)    # axes_mb[i].plot(years, mb.B, c='k', label='Modelled');    axes_mb[2].set_ylabel('B [mm w.e.]');       #convert mm w.e. to m w.e.    filtered_ds['dh']=filtered_ds['dh']        # Group by year and calculate the mean    # filtered_ds = filtered_ds.groupby('index.year').mean(dim='index')    axes_mb[i].plot(selected_ds.year,filtered_ds.dh,label='Modelled Hugonnet yearly', color='k')   plt.subplots_adjust(left=0.1, bottom=0.1, right=0.9, top=0.9, wspace=0.3, hspace=0.6)   plt.legend(ncol=3, loc='lower center', bbox_to_anchor=(0.5,-1.2))    